# Tower Game - Common Errors & Anti-Patterns
# Файл для предотвращения повторения синтаксических и логических ошибок

> **Правило**: Перед написанием ЛЮБОГО кода — прочитай этот файл.
> Если ошибка повторяется 2+ раз — добавь новый CE-XXX.

---

## Синтаксические ошибки (CE-001 — CE-099)

### CE-001: Неверные имена вариантов enum
- **Сессия**: 14
- **Файл**: engine/mod.rs
- **Ошибка**: Использовал `MasteryDomain::Sword` вместо `MasteryDomain::SwordMastery`
- **Правильно**:
  ```rust
  // mastery/mod.rs определяет:
  // SwordMastery, GreatswordMastery, DaggerMastery, SpearMastery,
  // GauntletMastery, StaffMastery, ParryMastery, DodgeMastery,
  // BlockMastery, AerialMastery, Blacksmithing, Alchemy,
  // Enchanting, Tailoring, Cooking, Mining, Herbalism,
  // Salvaging, Trading, Exploration, SemanticAttunement
  ```
- **Правило**: ВСЕГДА прочитай определение enum перед использованием. Не угадывай имена вариантов.
- **Повторения**: 1 (23 ошибки компиляции из-за одной причины)

### CE-002: Неверные имена методов/полей структуры
- **Сессия**: 14
- **Файл**: engine/mod.rs
- **Ошибки**:
  - `profile.get_tier()` → правильно: `profile.tier()`
  - `profile.add_xp()` → правильно: `profile.gain_xp(domain, amount)`
  - `profile.get_xp_info()` → нет такого метода, нужно: `profile.masteries.get(&domain)`
  - `sp.active_branches()` → нет такого метода, нужно: `sp.chosen_branches` (HashMap)
  - `sp.primary_role()` → это поле, не метод: `sp.primary_role` (pub field)
- **Правило**: ВСЕГДА прочитай `impl` блок структуры перед вызовом методов. Проверь: метод это или поле? Какие аргументы и типы возвращает?
- **Повторения**: 5 (в одном файле)

### CE-003: Несуществующие поля struct
- **Сессия**: 14
- **Файл**: engine/mod.rs
- **Ошибки**:
  - `synergy.required_branches` → правильно: `synergy.branch_a`, `synergy.branch_b`
  - `synergy.bonus_description` → правильно: `synergy.description`
- **Правило**: ВСЕГДА прочитай определение struct перед доступом к полям. Не предполагай имена полей.
- **Повторения**: 1

### CE-004: Импорт несуществующих типов
- **Сессия**: 14
- **Файл**: engine/mod.rs
- **Ошибки**:
  - `use crate::abilities::AbilityDef` → тип называется `Ability`, не `AbilityDef`
  - `use crate::equipment::GearSlot` → нет такого типа
  - `AbilityLoadout` в MasteryService — тип импортирован, но поле осталось после удаления импорта
- **Правило**: После удаления `use` — проверь ВСЕ использования этого типа в файле. Удали поля/переменные с этим типом.
- **Повторения**: 1

### CE-005: Несовпадение типов аргументов функций
- **Сессия**: 14
- **Файл**: engine/mod.rs
- **Ошибка**: `find_active_synergies(&SpecializationProfile)` — функция ожидает `&[String]`, а не структуру
- **Правило**: Проверь сигнатуру функции перед вызовом. Используй `cargo check` для ранней проверки.
- **Повторения**: 1

### CE-006: XP как u64, а не f32
- **Сессия**: 14
- **Файл**: engine/mod.rs
- **Ошибка**: Передавал `f32` в `gain_xp()`, который ожидает `u64`
- **Правило**: XP в mastery системе — ВСЕГДА `u64`. Используй `as u64` при конвертации.
- **Повторения**: 1

### CE-007: Bevy EventWriter API (версия 0.15)
- **Сессия**: 3
- **Ошибка**: Использовал `events.write()` вместо `events.send()` для EventWriter
- **Правильно**:
  ```rust
  // Bevy 0.15:
  events.send(MyEvent { ... }); // ✓
  // НЕ: events.write(MyEvent { ... }); // ✗
  ```
- **Повторения**: 2

### CE-008: Двойная JSON сериализация (to_json + json_to_cstring)
- **Сессия**: 15
- **Файл**: bridge/mod.rs
- **Ошибка**: `json_to_cstring(&profile.to_json())` — двойная сериализация. `to_json()` возвращает `String`, `json_to_cstring` снова сериализует String → получается `"\"{ ... }\""` вместо `"{ ... }"`
- **Правильно**:
  ```rust
  // Если struct реализует Serialize:
  json_to_cstring(&profile)  // ✓ — одна сериализация
  // НЕ:
  json_to_cstring(&profile.to_json()) // ✗ — двойная сериализация
  ```
- **Правило**: `json_to_cstring` УЖЕ сериализует через `serde_json::to_string`. Не вызывай `to_json()` перед ним.
- **Повторения**: 5 (все create_* функции FFI bridge)

### CE-009: Result vs bool — возвращаемые типы методов
- **Сессия**: 15
- **Файл**: bridge/mod.rs
- **Ошибка**: `if profile.choose_branch(...)` — ожидал `bool`, получил `Result<(), SpecError>`. Аналогично `insert_at()` → `Result<Option<SocketContent>, SocketError>`.
- **Правило**: ВСЕГДА проверяй возвращаемый тип метода. `Result` → используй `match`/`?`, `bool` → используй `if`.
- **Повторения**: 3

---

## Логические ошибки (CE-100 — CE-199)

### CE-100: Метод vs поле — вызов с ()
- **Сессия**: 14
- **Описание**: `sp.primary_role()` — вызывал как метод, хотя это `pub` поле
- **Правило**: Если `pub field_name: Type` — доступ через `obj.field_name` (без скобок). Если `fn method(&self) -> Type` — через `obj.method()`.
- **Как проверить**: Поиск `pub primary_role` vs `pub fn primary_role` в файле.

### CE-101: HashMap::values() vs struct method
- **Сессия**: 14
- **Описание**: Предполагал метод `active_branches()` у SpecializationProfile, хотя ветки хранятся в `HashMap<MasteryDomain, String>` (`chosen_branches`)
- **Правило**: Для итерации по HashMap — используй `.keys()`, `.values()`, `.iter()`. Не предполагай наличие обёрточных методов.

### CE-102: Seed + Delta — детерминизм
- **Сессия**: 10, 14
- **Описание**: Генерация этажей ОБЯЗАНА быть детерминистичной. Один и тот же seed + floor_id = один и тот же результат.
- **Правило**: НИКОГДА не использовать `rand::thread_rng()` в генерации. Только `StdRng::seed_from_u64(hash)`.
- **Тест**: `test_floor_deterministic` проверяет это.

### CE-103: Статы — ТОЛЬКО при создании персонажа
- **Сессия**: 12
- **Описание**: По дизайну, базовые статы (strength, agility и т.д.) распределяются ТОЛЬКО при создании персонажа. Дополнительные статы — ТОЛЬКО от экипировки.
- **Правило**: НЕ добавлять систему "level up + stat points". Прогресс через MASTERY (использование навыков).

### CE-104: Экипировка даёт ЭФФЕКТЫ, не большие статы
- **Сессия**: 12
- **Описание**: Оружие/броня дают уникальные эффекты (Trigger→Action), НЕ +50 к атаке.
- **Правило**: StatBonuses экипировки МАЛЕНЬКИЕ (1-5%). Основная ценность — уникальные эффекты и сет-бонусы.

---

## Ошибки среды разработки (CE-200 — CE-299)

### CE-200: MinGW PATH не сохраняется между вызовами Bash
- **Сессия**: 2, 3, 4, ...14
- **Описание**: Каждый вызов Bash — новый shell. `export PATH=...` НЕ сохраняется.
- **Правильно**:
  ```bash
  # ВСЕГДА в одной команде:
  export PATH="/c/Users/Plax/AppData/Local/Microsoft/WinGet/Packages/BrechtSanders.WinLibs.POSIX.UCRT_Microsoft.Winget.Source_8wekyb3d8bbwe/mingw64/bin:$PATH" && cd c:/Users/Plax/Desktop/tower_game/procedural-core && cargo test 2>&1
  ```
- **Правило**: НИКОГДА не разделяй `export PATH=...` и `cargo ...` на два вызова Bash.
- **Повторения**: 10+

### CE-201: Edit tool — файл должен быть прочитан
- **Сессия**: 14
- **Описание**: Edit/Write tool выдаёт "File has not been read yet" если файл не был прочитан Read tool в текущей сессии
- **Правило**: ВСЕГДА вызывай Read перед Edit/Write для существующих файлов.
- **Повторения**: 3+

### CE-202: Windows Bash — grep/head/tail/sed/awk недоступны
- **Сессия**: 2-14
- **Описание**: В Git Bash на Windows эти команды часто не работают или работают нестабильно.
- **Правило**: Используй Grep/Read/Glob инструменты Claude Code вместо команд shell.
- **Повторения**: 5+

### CE-203: cargo test без 2>&1 — вывод обрезается
- **Сессия**: 3
- **Описание**: `cargo test` пишет в stderr, без `2>&1` вывод может быть потерян
- **Правило**: ВСЕГДА добавляй `2>&1` после `cargo test`, `cargo build`, `cargo check`.

---

## Ошибки интеграции (CE-300 — CE-399)

### CE-300: JSON format alignment Rust↔UE5
- **Сессия**: 4
- **Описание**: Rust сериализует 2D массив tiles как `[[...]]`, UE5 ожидает плоский `[...]`. Имена полей в JSON должны ТОЧНО совпадать.
- **Правило**: Всегда проверяй JSON формат на обоих концах. Используй тесты с реальными JSON строками.

### CE-301: gRPC/Proto — нумерация полей
- **Сессия**: 14
- **Описание**: В .proto файлах нумерация полей начинается с 1 и должна быть уникальной в пределах message.
- **Правило**: Не переиспользуй номера полей. Удалённые поля помечай `reserved`.

---

## Лучшие практики (BP-001 — BP-099)

### BP-001: Перед написанием кода с использованием API другого модуля
1. Прочитай **определение структуры** (`struct`, `enum`)
2. Прочитай **impl блок** (список методов + сигнатуры)
3. Прочитай **тесты модуля** (примеры использования)
4. Только потом пиши свой код

### BP-002: Порядок сборки
1. `cargo check` — быстрая проверка типов (30 сек)
2. Исправь ВСЕ ошибки
3. `cargo test` — полный тест (2-3 мин)
4. Проверь warnings

### BP-003: Новый модуль Rust
1. Создай файл `module_name/mod.rs`
2. Добавь `pub mod module_name;` в `lib.rs`
3. Добавь `mod module_name;` в `main.rs`
4. Добавь `.add_plugins(module_name::ModulePlugin)` в main App
5. Запусти `cargo check`

### BP-004: Новый UE5 C++ класс
1. Создай `.h` файл с UCLASS() макросом
2. Создай `.cpp` файл с #include
3. Проверь что класс добавлен в Build.cs модули (при необходимости)
4. Используй UPROPERTY()/UFUNCTION() для Blueprint-доступных свойств
5. Добавь BlueprintCallable/BlueprintReadOnly для публичных API

### BP-005: Параллельные Task агенты
- Используй параллельные агенты для НЕЗАВИСИМЫХ задач (например, 4 UE5 виджета одновременно)
- НЕ используй для задач с зависимостями (создание файла + его использование)

---

## Статистика ошибок

| Категория | Количество | Самая частая |
|-----------|------------|--------------|
| Неверные имена enum/методов | 8 | CE-001, CE-002 |
| Среда разработки (PATH, tools) | 15+ | CE-200 |
| Типы аргументов / возвращаемые типы | 5 | CE-005, CE-009 |
| Несуществующие imports | 3 | CE-004 |
| JSON двойная сериализация | 5 | CE-008 |
| JSON формат | 1 | CE-300 |

**Главный вывод**: 80% ошибок = не прочитал определение структуры/enum/метода перед использованием.
**Решение**: BP-001 — ВСЕГДА читай API перед написанием кода.

---

*Последнее обновление: Сессия 15 (2026-02-14)*
*Всего паттернов: 18 CE + 5 BP*
