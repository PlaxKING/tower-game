// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: game_state.proto
// Protobuf C++ Version: 5.27.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_game_5fstate_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_game_5fstate_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_game_5fstate_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_game_5fstate_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_game_5fstate_2eproto;
namespace tower {
namespace game {
class ChunkData;
struct ChunkDataDefaultTypeInternal;
extern ChunkDataDefaultTypeInternal _ChunkData_default_instance_;
class ClientPacket;
struct ClientPacketDefaultTypeInternal;
extern ClientPacketDefaultTypeInternal _ClientPacket_default_instance_;
class ConnectionAccepted;
struct ConnectionAcceptedDefaultTypeInternal;
extern ConnectionAcceptedDefaultTypeInternal _ConnectionAccepted_default_instance_;
class EntitySnapshot;
struct EntitySnapshotDefaultTypeInternal;
extern EntitySnapshotDefaultTypeInternal _EntitySnapshot_default_instance_;
class FloorTileData;
struct FloorTileDataDefaultTypeInternal;
extern FloorTileDataDefaultTypeInternal _FloorTileData_default_instance_;
class MonsterData;
struct MonsterDataDefaultTypeInternal;
extern MonsterDataDefaultTypeInternal _MonsterData_default_instance_;
class PlayerData;
struct PlayerDataDefaultTypeInternal;
extern PlayerDataDefaultTypeInternal _PlayerData_default_instance_;
class PlayerInput;
struct PlayerInputDefaultTypeInternal;
extern PlayerInputDefaultTypeInternal _PlayerInput_default_instance_;
class Rotation;
struct RotationDefaultTypeInternal;
extern RotationDefaultTypeInternal _Rotation_default_instance_;
class ServerPacket;
struct ServerPacketDefaultTypeInternal;
extern ServerPacketDefaultTypeInternal _ServerPacket_default_instance_;
class Vec3;
struct Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
class Velocity;
struct VelocityDefaultTypeInternal;
extern VelocityDefaultTypeInternal _Velocity_default_instance_;
class WorldSnapshot;
struct WorldSnapshotDefaultTypeInternal;
extern WorldSnapshotDefaultTypeInternal _WorldSnapshot_default_instance_;
}  // namespace game
}  // namespace tower
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tower {
namespace game {

// ===================================================================


// -------------------------------------------------------------------

class Velocity final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.Velocity) */ {
 public:
  inline Velocity() : Velocity(nullptr) {}
  ~Velocity() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Velocity(
      ::google::protobuf::internal::ConstantInitialized);

  inline Velocity(const Velocity& from) : Velocity(nullptr, from) {}
  inline Velocity(Velocity&& from) noexcept
      : Velocity(nullptr, std::move(from)) {}
  inline Velocity& operator=(const Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Velocity& operator=(Velocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Velocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Velocity* internal_default_instance() {
    return reinterpret_cast<const Velocity*>(
        &_Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Velocity& a, Velocity& b) { a.Swap(&b); }
  inline void Swap(Velocity* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Velocity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Velocity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Velocity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Velocity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Velocity& from) { Velocity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Velocity* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.Velocity"; }

 protected:
  explicit Velocity(::google::protobuf::Arena* arena);
  Velocity(::google::protobuf::Arena* arena, const Velocity& from);
  Velocity(::google::protobuf::Arena* arena, Velocity&& from) noexcept
      : Velocity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:tower.game.Velocity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Velocity_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Velocity& from_msg);
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class Vec3 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.Vec3) */ {
 public:
  inline Vec3() : Vec3(nullptr) {}
  ~Vec3() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vec3(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vec3(const Vec3& from) : Vec3(nullptr, from) {}
  inline Vec3(Vec3&& from) noexcept
      : Vec3(nullptr, std::move(from)) {}
  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
        &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Vec3& a, Vec3& b) { a.Swap(&b); }
  inline void Swap(Vec3* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Vec3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vec3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vec3& from) { Vec3::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vec3* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.Vec3"; }

 protected:
  explicit Vec3(::google::protobuf::Arena* arena);
  Vec3(::google::protobuf::Arena* arena, const Vec3& from);
  Vec3(::google::protobuf::Arena* arena, Vec3&& from) noexcept
      : Vec3(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:tower.game.Vec3)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Vec3_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vec3& from_msg);
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class Rotation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.Rotation) */ {
 public:
  inline Rotation() : Rotation(nullptr) {}
  ~Rotation() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Rotation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Rotation(const Rotation& from) : Rotation(nullptr, from) {}
  inline Rotation(Rotation&& from) noexcept
      : Rotation(nullptr, std::move(from)) {}
  inline Rotation& operator=(const Rotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rotation& operator=(Rotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rotation* internal_default_instance() {
    return reinterpret_cast<const Rotation*>(
        &_Rotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Rotation& a, Rotation& b) { a.Swap(&b); }
  inline void Swap(Rotation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rotation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rotation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Rotation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rotation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Rotation& from) { Rotation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rotation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.Rotation"; }

 protected:
  explicit Rotation(::google::protobuf::Arena* arena);
  Rotation(::google::protobuf::Arena* arena, const Rotation& from);
  Rotation(::google::protobuf::Arena* arena, Rotation&& from) noexcept
      : Rotation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPitchFieldNumber = 1,
    kYawFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // float pitch = 1;
  void clear_pitch() ;
  float pitch() const;
  void set_pitch(float value);

  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);

  public:
  // float yaw = 2;
  void clear_yaw() ;
  float yaw() const;
  void set_yaw(float value);

  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);

  public:
  // float roll = 3;
  void clear_roll() ;
  float roll() const;
  void set_roll(float value);

  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);

  public:
  // @@protoc_insertion_point(class_scope:tower.game.Rotation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Rotation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Rotation& from_msg);
    float pitch_;
    float yaw_;
    float roll_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class FloorTileData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.FloorTileData) */ {
 public:
  inline FloorTileData() : FloorTileData(nullptr) {}
  ~FloorTileData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FloorTileData(
      ::google::protobuf::internal::ConstantInitialized);

  inline FloorTileData(const FloorTileData& from) : FloorTileData(nullptr, from) {}
  inline FloorTileData(FloorTileData&& from) noexcept
      : FloorTileData(nullptr, std::move(from)) {}
  inline FloorTileData& operator=(const FloorTileData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloorTileData& operator=(FloorTileData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloorTileData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloorTileData* internal_default_instance() {
    return reinterpret_cast<const FloorTileData*>(
        &_FloorTileData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(FloorTileData& a, FloorTileData& b) { a.Swap(&b); }
  inline void Swap(FloorTileData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloorTileData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloorTileData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FloorTileData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FloorTileData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FloorTileData& from) { FloorTileData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FloorTileData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.FloorTileData"; }

 protected:
  explicit FloorTileData(::google::protobuf::Arena* arena);
  FloorTileData(::google::protobuf::Arena* arena, const FloorTileData& from);
  FloorTileData(::google::protobuf::Arena* arena, FloorTileData&& from) noexcept
      : FloorTileData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTileTypeFieldNumber = 1,
    kGridXFieldNumber = 2,
    kGridYFieldNumber = 3,
    kBiomeIdFieldNumber = 4,
    kIsWalkableFieldNumber = 5,
    kHasCollisionFieldNumber = 6,
  };
  // uint32 tile_type = 1;
  void clear_tile_type() ;
  ::uint32_t tile_type() const;
  void set_tile_type(::uint32_t value);

  private:
  ::uint32_t _internal_tile_type() const;
  void _internal_set_tile_type(::uint32_t value);

  public:
  // int32 grid_x = 2;
  void clear_grid_x() ;
  ::int32_t grid_x() const;
  void set_grid_x(::int32_t value);

  private:
  ::int32_t _internal_grid_x() const;
  void _internal_set_grid_x(::int32_t value);

  public:
  // int32 grid_y = 3;
  void clear_grid_y() ;
  ::int32_t grid_y() const;
  void set_grid_y(::int32_t value);

  private:
  ::int32_t _internal_grid_y() const;
  void _internal_set_grid_y(::int32_t value);

  public:
  // uint32 biome_id = 4;
  void clear_biome_id() ;
  ::uint32_t biome_id() const;
  void set_biome_id(::uint32_t value);

  private:
  ::uint32_t _internal_biome_id() const;
  void _internal_set_biome_id(::uint32_t value);

  public:
  // bool is_walkable = 5;
  void clear_is_walkable() ;
  bool is_walkable() const;
  void set_is_walkable(bool value);

  private:
  bool _internal_is_walkable() const;
  void _internal_set_is_walkable(bool value);

  public:
  // bool has_collision = 6;
  void clear_has_collision() ;
  bool has_collision() const;
  void set_has_collision(bool value);

  private:
  bool _internal_has_collision() const;
  void _internal_set_has_collision(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tower.game.FloorTileData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FloorTileData_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FloorTileData& from_msg);
    ::uint32_t tile_type_;
    ::int32_t grid_x_;
    ::int32_t grid_y_;
    ::uint32_t biome_id_;
    bool is_walkable_;
    bool has_collision_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class PlayerInput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.PlayerInput) */ {
 public:
  inline PlayerInput() : PlayerInput(nullptr) {}
  ~PlayerInput() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerInput(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerInput(const PlayerInput& from) : PlayerInput(nullptr, from) {}
  inline PlayerInput(PlayerInput&& from) noexcept
      : PlayerInput(nullptr, std::move(from)) {}
  inline PlayerInput& operator=(const PlayerInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInput& operator=(PlayerInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInput* internal_default_instance() {
    return reinterpret_cast<const PlayerInput*>(
        &_PlayerInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(PlayerInput& a, PlayerInput& b) { a.Swap(&b); }
  inline void Swap(PlayerInput* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerInput& from) { PlayerInput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerInput* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.PlayerInput"; }

 protected:
  explicit PlayerInput(::google::protobuf::Arena* arena);
  PlayerInput(::google::protobuf::Arena* arena, const PlayerInput& from);
  PlayerInput(::google::protobuf::Arena* arena, PlayerInput&& from) noexcept
      : PlayerInput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMovementDirectionFieldNumber = 3,
    kCameraRotationFieldNumber = 6,
    kAimDirectionFieldNumber = 7,
    kClientTickFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kTargetEntityFieldNumber = 9,
    kTimestampFieldNumber = 10,
    kJumpPressedFieldNumber = 4,
    kDashPressedFieldNumber = 5,
    kAttackPressedFieldNumber = 8,
  };
  // .tower.game.Vec3 movement_direction = 3;
  bool has_movement_direction() const;
  void clear_movement_direction() ;
  const ::tower::game::Vec3& movement_direction() const;
  PROTOBUF_NODISCARD ::tower::game::Vec3* release_movement_direction();
  ::tower::game::Vec3* mutable_movement_direction();
  void set_allocated_movement_direction(::tower::game::Vec3* value);
  void unsafe_arena_set_allocated_movement_direction(::tower::game::Vec3* value);
  ::tower::game::Vec3* unsafe_arena_release_movement_direction();

  private:
  const ::tower::game::Vec3& _internal_movement_direction() const;
  ::tower::game::Vec3* _internal_mutable_movement_direction();

  public:
  // .tower.game.Rotation camera_rotation = 6;
  bool has_camera_rotation() const;
  void clear_camera_rotation() ;
  const ::tower::game::Rotation& camera_rotation() const;
  PROTOBUF_NODISCARD ::tower::game::Rotation* release_camera_rotation();
  ::tower::game::Rotation* mutable_camera_rotation();
  void set_allocated_camera_rotation(::tower::game::Rotation* value);
  void unsafe_arena_set_allocated_camera_rotation(::tower::game::Rotation* value);
  ::tower::game::Rotation* unsafe_arena_release_camera_rotation();

  private:
  const ::tower::game::Rotation& _internal_camera_rotation() const;
  ::tower::game::Rotation* _internal_mutable_camera_rotation();

  public:
  // .tower.game.Vec3 aim_direction = 7;
  bool has_aim_direction() const;
  void clear_aim_direction() ;
  const ::tower::game::Vec3& aim_direction() const;
  PROTOBUF_NODISCARD ::tower::game::Vec3* release_aim_direction();
  ::tower::game::Vec3* mutable_aim_direction();
  void set_allocated_aim_direction(::tower::game::Vec3* value);
  void unsafe_arena_set_allocated_aim_direction(::tower::game::Vec3* value);
  ::tower::game::Vec3* unsafe_arena_release_aim_direction();

  private:
  const ::tower::game::Vec3& _internal_aim_direction() const;
  ::tower::game::Vec3* _internal_mutable_aim_direction();

  public:
  // uint64 client_tick = 1;
  void clear_client_tick() ;
  ::uint64_t client_tick() const;
  void set_client_tick(::uint64_t value);

  private:
  ::uint64_t _internal_client_tick() const;
  void _internal_set_client_tick(::uint64_t value);

  public:
  // uint64 player_id = 2;
  void clear_player_id() ;
  ::uint64_t player_id() const;
  void set_player_id(::uint64_t value);

  private:
  ::uint64_t _internal_player_id() const;
  void _internal_set_player_id(::uint64_t value);

  public:
  // uint64 target_entity = 9;
  void clear_target_entity() ;
  ::uint64_t target_entity() const;
  void set_target_entity(::uint64_t value);

  private:
  ::uint64_t _internal_target_entity() const;
  void _internal_set_target_entity(::uint64_t value);

  public:
  // uint64 timestamp = 10;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // bool jump_pressed = 4;
  void clear_jump_pressed() ;
  bool jump_pressed() const;
  void set_jump_pressed(bool value);

  private:
  bool _internal_jump_pressed() const;
  void _internal_set_jump_pressed(bool value);

  public:
  // bool dash_pressed = 5;
  void clear_dash_pressed() ;
  bool dash_pressed() const;
  void set_dash_pressed(bool value);

  private:
  bool _internal_dash_pressed() const;
  void _internal_set_dash_pressed(bool value);

  public:
  // bool attack_pressed = 8;
  void clear_attack_pressed() ;
  bool attack_pressed() const;
  void set_attack_pressed(bool value);

  private:
  bool _internal_attack_pressed() const;
  void _internal_set_attack_pressed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tower.game.PlayerInput)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayerInput_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerInput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::tower::game::Vec3* movement_direction_;
    ::tower::game::Rotation* camera_rotation_;
    ::tower::game::Vec3* aim_direction_;
    ::uint64_t client_tick_;
    ::uint64_t player_id_;
    ::uint64_t target_entity_;
    ::uint64_t timestamp_;
    bool jump_pressed_;
    bool dash_pressed_;
    bool attack_pressed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class PlayerData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.PlayerData) */ {
 public:
  inline PlayerData() : PlayerData(nullptr) {}
  ~PlayerData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerData(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerData(const PlayerData& from) : PlayerData(nullptr, from) {}
  inline PlayerData(PlayerData&& from) noexcept
      : PlayerData(nullptr, std::move(from)) {}
  inline PlayerData& operator=(const PlayerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerData& operator=(PlayerData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerData* internal_default_instance() {
    return reinterpret_cast<const PlayerData*>(
        &_PlayerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(PlayerData& a, PlayerData& b) { a.Swap(&b); }
  inline void Swap(PlayerData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerData& from) { PlayerData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.PlayerData"; }

 protected:
  explicit PlayerData(::google::protobuf::Arena* arena);
  PlayerData(::google::protobuf::Arena* arena, const PlayerData& from);
  PlayerData(::google::protobuf::Arena* arena, PlayerData&& from) noexcept
      : PlayerData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerNameFieldNumber = 8,
    kPositionFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kRotationFieldNumber = 4,
    kIdFieldNumber = 1,
    kHealthFieldNumber = 5,
    kMaxHealthFieldNumber = 6,
    kCurrentFloorFieldNumber = 7,
    kLevelFieldNumber = 9,
    kTargetEntityFieldNumber = 11,
    kInCombatFieldNumber = 10,
    kIsGroundedFieldNumber = 12,
    kIsFlyingFieldNumber = 13,
    kIsDashingFieldNumber = 14,
  };
  // string player_name = 8;
  void clear_player_name() ;
  const std::string& player_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_name(Arg_&& arg, Args_... args);
  std::string* mutable_player_name();
  PROTOBUF_NODISCARD std::string* release_player_name();
  void set_allocated_player_name(std::string* value);

  private:
  const std::string& _internal_player_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_name(
      const std::string& value);
  std::string* _internal_mutable_player_name();

  public:
  // .tower.game.Vec3 position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::tower::game::Vec3& position() const;
  PROTOBUF_NODISCARD ::tower::game::Vec3* release_position();
  ::tower::game::Vec3* mutable_position();
  void set_allocated_position(::tower::game::Vec3* value);
  void unsafe_arena_set_allocated_position(::tower::game::Vec3* value);
  ::tower::game::Vec3* unsafe_arena_release_position();

  private:
  const ::tower::game::Vec3& _internal_position() const;
  ::tower::game::Vec3* _internal_mutable_position();

  public:
  // .tower.game.Velocity velocity = 3;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::tower::game::Velocity& velocity() const;
  PROTOBUF_NODISCARD ::tower::game::Velocity* release_velocity();
  ::tower::game::Velocity* mutable_velocity();
  void set_allocated_velocity(::tower::game::Velocity* value);
  void unsafe_arena_set_allocated_velocity(::tower::game::Velocity* value);
  ::tower::game::Velocity* unsafe_arena_release_velocity();

  private:
  const ::tower::game::Velocity& _internal_velocity() const;
  ::tower::game::Velocity* _internal_mutable_velocity();

  public:
  // .tower.game.Rotation rotation = 4;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::tower::game::Rotation& rotation() const;
  PROTOBUF_NODISCARD ::tower::game::Rotation* release_rotation();
  ::tower::game::Rotation* mutable_rotation();
  void set_allocated_rotation(::tower::game::Rotation* value);
  void unsafe_arena_set_allocated_rotation(::tower::game::Rotation* value);
  ::tower::game::Rotation* unsafe_arena_release_rotation();

  private:
  const ::tower::game::Rotation& _internal_rotation() const;
  ::tower::game::Rotation* _internal_mutable_rotation();

  public:
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // float health = 5;
  void clear_health() ;
  float health() const;
  void set_health(float value);

  private:
  float _internal_health() const;
  void _internal_set_health(float value);

  public:
  // float max_health = 6;
  void clear_max_health() ;
  float max_health() const;
  void set_max_health(float value);

  private:
  float _internal_max_health() const;
  void _internal_set_max_health(float value);

  public:
  // uint32 current_floor = 7;
  void clear_current_floor() ;
  ::uint32_t current_floor() const;
  void set_current_floor(::uint32_t value);

  private:
  ::uint32_t _internal_current_floor() const;
  void _internal_set_current_floor(::uint32_t value);

  public:
  // uint32 level = 9;
  void clear_level() ;
  ::uint32_t level() const;
  void set_level(::uint32_t value);

  private:
  ::uint32_t _internal_level() const;
  void _internal_set_level(::uint32_t value);

  public:
  // uint64 target_entity = 11;
  void clear_target_entity() ;
  ::uint64_t target_entity() const;
  void set_target_entity(::uint64_t value);

  private:
  ::uint64_t _internal_target_entity() const;
  void _internal_set_target_entity(::uint64_t value);

  public:
  // bool in_combat = 10;
  void clear_in_combat() ;
  bool in_combat() const;
  void set_in_combat(bool value);

  private:
  bool _internal_in_combat() const;
  void _internal_set_in_combat(bool value);

  public:
  // bool is_grounded = 12;
  void clear_is_grounded() ;
  bool is_grounded() const;
  void set_is_grounded(bool value);

  private:
  bool _internal_is_grounded() const;
  void _internal_set_is_grounded(bool value);

  public:
  // bool is_flying = 13;
  void clear_is_flying() ;
  bool is_flying() const;
  void set_is_flying(bool value);

  private:
  bool _internal_is_flying() const;
  void _internal_set_is_flying(bool value);

  public:
  // bool is_dashing = 14;
  void clear_is_dashing() ;
  bool is_dashing() const;
  void set_is_dashing(bool value);

  private:
  bool _internal_is_dashing() const;
  void _internal_set_is_dashing(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tower.game.PlayerData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 3,
      49, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayerData_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_name_;
    ::tower::game::Vec3* position_;
    ::tower::game::Velocity* velocity_;
    ::tower::game::Rotation* rotation_;
    ::uint64_t id_;
    float health_;
    float max_health_;
    ::uint32_t current_floor_;
    ::uint32_t level_;
    ::uint64_t target_entity_;
    bool in_combat_;
    bool is_grounded_;
    bool is_flying_;
    bool is_dashing_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class MonsterData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.MonsterData) */ {
 public:
  inline MonsterData() : MonsterData(nullptr) {}
  ~MonsterData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MonsterData(
      ::google::protobuf::internal::ConstantInitialized);

  inline MonsterData(const MonsterData& from) : MonsterData(nullptr, from) {}
  inline MonsterData(MonsterData&& from) noexcept
      : MonsterData(nullptr, std::move(from)) {}
  inline MonsterData& operator=(const MonsterData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterData& operator=(MonsterData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonsterData* internal_default_instance() {
    return reinterpret_cast<const MonsterData*>(
        &_MonsterData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(MonsterData& a, MonsterData& b) { a.Swap(&b); }
  inline void Swap(MonsterData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MonsterData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MonsterData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MonsterData& from) { MonsterData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MonsterData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.MonsterData"; }

 protected:
  explicit MonsterData(::google::protobuf::Arena* arena);
  MonsterData(::google::protobuf::Arena* arena, const MonsterData& from);
  MonsterData(::google::protobuf::Arena* arena, MonsterData&& from) noexcept
      : MonsterData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMonsterTypeFieldNumber = 2,
    kAiStateFieldNumber = 9,
    kPositionFieldNumber = 3,
    kVelocityFieldNumber = 4,
    kRotationFieldNumber = 5,
    kIdFieldNumber = 1,
    kHealthFieldNumber = 6,
    kMaxHealthFieldNumber = 7,
    kFloorIdFieldNumber = 8,
    kAttackDamageFieldNumber = 11,
    kTargetPlayerFieldNumber = 10,
    kAttackRangeFieldNumber = 12,
    kMovementSpeedFieldNumber = 13,
  };
  // string monster_type = 2;
  void clear_monster_type() ;
  const std::string& monster_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_monster_type(Arg_&& arg, Args_... args);
  std::string* mutable_monster_type();
  PROTOBUF_NODISCARD std::string* release_monster_type();
  void set_allocated_monster_type(std::string* value);

  private:
  const std::string& _internal_monster_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_monster_type(
      const std::string& value);
  std::string* _internal_mutable_monster_type();

  public:
  // string ai_state = 9;
  void clear_ai_state() ;
  const std::string& ai_state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ai_state(Arg_&& arg, Args_... args);
  std::string* mutable_ai_state();
  PROTOBUF_NODISCARD std::string* release_ai_state();
  void set_allocated_ai_state(std::string* value);

  private:
  const std::string& _internal_ai_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ai_state(
      const std::string& value);
  std::string* _internal_mutable_ai_state();

  public:
  // .tower.game.Vec3 position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::tower::game::Vec3& position() const;
  PROTOBUF_NODISCARD ::tower::game::Vec3* release_position();
  ::tower::game::Vec3* mutable_position();
  void set_allocated_position(::tower::game::Vec3* value);
  void unsafe_arena_set_allocated_position(::tower::game::Vec3* value);
  ::tower::game::Vec3* unsafe_arena_release_position();

  private:
  const ::tower::game::Vec3& _internal_position() const;
  ::tower::game::Vec3* _internal_mutable_position();

  public:
  // .tower.game.Velocity velocity = 4;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::tower::game::Velocity& velocity() const;
  PROTOBUF_NODISCARD ::tower::game::Velocity* release_velocity();
  ::tower::game::Velocity* mutable_velocity();
  void set_allocated_velocity(::tower::game::Velocity* value);
  void unsafe_arena_set_allocated_velocity(::tower::game::Velocity* value);
  ::tower::game::Velocity* unsafe_arena_release_velocity();

  private:
  const ::tower::game::Velocity& _internal_velocity() const;
  ::tower::game::Velocity* _internal_mutable_velocity();

  public:
  // .tower.game.Rotation rotation = 5;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::tower::game::Rotation& rotation() const;
  PROTOBUF_NODISCARD ::tower::game::Rotation* release_rotation();
  ::tower::game::Rotation* mutable_rotation();
  void set_allocated_rotation(::tower::game::Rotation* value);
  void unsafe_arena_set_allocated_rotation(::tower::game::Rotation* value);
  ::tower::game::Rotation* unsafe_arena_release_rotation();

  private:
  const ::tower::game::Rotation& _internal_rotation() const;
  ::tower::game::Rotation* _internal_mutable_rotation();

  public:
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // float health = 6;
  void clear_health() ;
  float health() const;
  void set_health(float value);

  private:
  float _internal_health() const;
  void _internal_set_health(float value);

  public:
  // float max_health = 7;
  void clear_max_health() ;
  float max_health() const;
  void set_max_health(float value);

  private:
  float _internal_max_health() const;
  void _internal_set_max_health(float value);

  public:
  // uint32 floor_id = 8;
  void clear_floor_id() ;
  ::uint32_t floor_id() const;
  void set_floor_id(::uint32_t value);

  private:
  ::uint32_t _internal_floor_id() const;
  void _internal_set_floor_id(::uint32_t value);

  public:
  // float attack_damage = 11;
  void clear_attack_damage() ;
  float attack_damage() const;
  void set_attack_damage(float value);

  private:
  float _internal_attack_damage() const;
  void _internal_set_attack_damage(float value);

  public:
  // uint64 target_player = 10;
  void clear_target_player() ;
  ::uint64_t target_player() const;
  void set_target_player(::uint64_t value);

  private:
  ::uint64_t _internal_target_player() const;
  void _internal_set_target_player(::uint64_t value);

  public:
  // float attack_range = 12;
  void clear_attack_range() ;
  float attack_range() const;
  void set_attack_range(float value);

  private:
  float _internal_attack_range() const;
  void _internal_set_attack_range(float value);

  public:
  // float movement_speed = 13;
  void clear_movement_speed() ;
  float movement_speed() const;
  void set_movement_speed(float value);

  private:
  float _internal_movement_speed() const;
  void _internal_set_movement_speed(float value);

  public:
  // @@protoc_insertion_point(class_scope:tower.game.MonsterData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 3,
      59, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MonsterData_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MonsterData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr monster_type_;
    ::google::protobuf::internal::ArenaStringPtr ai_state_;
    ::tower::game::Vec3* position_;
    ::tower::game::Velocity* velocity_;
    ::tower::game::Rotation* rotation_;
    ::uint64_t id_;
    float health_;
    float max_health_;
    ::uint32_t floor_id_;
    float attack_damage_;
    ::uint64_t target_player_;
    float attack_range_;
    float movement_speed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class EntitySnapshot final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.EntitySnapshot) */ {
 public:
  inline EntitySnapshot() : EntitySnapshot(nullptr) {}
  ~EntitySnapshot() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntitySnapshot(
      ::google::protobuf::internal::ConstantInitialized);

  inline EntitySnapshot(const EntitySnapshot& from) : EntitySnapshot(nullptr, from) {}
  inline EntitySnapshot(EntitySnapshot&& from) noexcept
      : EntitySnapshot(nullptr, std::move(from)) {}
  inline EntitySnapshot& operator=(const EntitySnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntitySnapshot& operator=(EntitySnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntitySnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntitySnapshot* internal_default_instance() {
    return reinterpret_cast<const EntitySnapshot*>(
        &_EntitySnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(EntitySnapshot& a, EntitySnapshot& b) { a.Swap(&b); }
  inline void Swap(EntitySnapshot* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntitySnapshot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntitySnapshot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EntitySnapshot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntitySnapshot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntitySnapshot& from) { EntitySnapshot::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EntitySnapshot* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.EntitySnapshot"; }

 protected:
  explicit EntitySnapshot(::google::protobuf::Arena* arena);
  EntitySnapshot(::google::protobuf::Arena* arena, const EntitySnapshot& from);
  EntitySnapshot(::google::protobuf::Arena* arena, EntitySnapshot&& from) noexcept
      : EntitySnapshot(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStateFieldNumber = 7,
    kPositionFieldNumber = 3,
    kVelocityFieldNumber = 4,
    kRotationFieldNumber = 5,
    kEntityIdFieldNumber = 1,
    kChangedFieldsFieldNumber = 2,
    kHealthFieldNumber = 6,
  };
  // optional string state = 7;
  bool has_state() const;
  void clear_state() ;
  const std::string& state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* value);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // optional .tower.game.Vec3 position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::tower::game::Vec3& position() const;
  PROTOBUF_NODISCARD ::tower::game::Vec3* release_position();
  ::tower::game::Vec3* mutable_position();
  void set_allocated_position(::tower::game::Vec3* value);
  void unsafe_arena_set_allocated_position(::tower::game::Vec3* value);
  ::tower::game::Vec3* unsafe_arena_release_position();

  private:
  const ::tower::game::Vec3& _internal_position() const;
  ::tower::game::Vec3* _internal_mutable_position();

  public:
  // optional .tower.game.Velocity velocity = 4;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::tower::game::Velocity& velocity() const;
  PROTOBUF_NODISCARD ::tower::game::Velocity* release_velocity();
  ::tower::game::Velocity* mutable_velocity();
  void set_allocated_velocity(::tower::game::Velocity* value);
  void unsafe_arena_set_allocated_velocity(::tower::game::Velocity* value);
  ::tower::game::Velocity* unsafe_arena_release_velocity();

  private:
  const ::tower::game::Velocity& _internal_velocity() const;
  ::tower::game::Velocity* _internal_mutable_velocity();

  public:
  // optional .tower.game.Rotation rotation = 5;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::tower::game::Rotation& rotation() const;
  PROTOBUF_NODISCARD ::tower::game::Rotation* release_rotation();
  ::tower::game::Rotation* mutable_rotation();
  void set_allocated_rotation(::tower::game::Rotation* value);
  void unsafe_arena_set_allocated_rotation(::tower::game::Rotation* value);
  ::tower::game::Rotation* unsafe_arena_release_rotation();

  private:
  const ::tower::game::Rotation& _internal_rotation() const;
  ::tower::game::Rotation* _internal_mutable_rotation();

  public:
  // uint64 entity_id = 1;
  void clear_entity_id() ;
  ::uint64_t entity_id() const;
  void set_entity_id(::uint64_t value);

  private:
  ::uint64_t _internal_entity_id() const;
  void _internal_set_entity_id(::uint64_t value);

  public:
  // uint32 changed_fields = 2;
  void clear_changed_fields() ;
  ::uint32_t changed_fields() const;
  void set_changed_fields(::uint32_t value);

  private:
  ::uint32_t _internal_changed_fields() const;
  void _internal_set_changed_fields(::uint32_t value);

  public:
  // optional float health = 6;
  bool has_health() const;
  void clear_health() ;
  float health() const;
  void set_health(float value);

  private:
  float _internal_health() const;
  void _internal_set_health(float value);

  public:
  // @@protoc_insertion_point(class_scope:tower.game.EntitySnapshot)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      39, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EntitySnapshot_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EntitySnapshot& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr state_;
    ::tower::game::Vec3* position_;
    ::tower::game::Velocity* velocity_;
    ::tower::game::Rotation* rotation_;
    ::uint64_t entity_id_;
    ::uint32_t changed_fields_;
    float health_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class ConnectionAccepted final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.ConnectionAccepted) */ {
 public:
  inline ConnectionAccepted() : ConnectionAccepted(nullptr) {}
  ~ConnectionAccepted() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectionAccepted(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConnectionAccepted(const ConnectionAccepted& from) : ConnectionAccepted(nullptr, from) {}
  inline ConnectionAccepted(ConnectionAccepted&& from) noexcept
      : ConnectionAccepted(nullptr, std::move(from)) {}
  inline ConnectionAccepted& operator=(const ConnectionAccepted& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionAccepted& operator=(ConnectionAccepted&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionAccepted& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionAccepted* internal_default_instance() {
    return reinterpret_cast<const ConnectionAccepted*>(
        &_ConnectionAccepted_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ConnectionAccepted& a, ConnectionAccepted& b) { a.Swap(&b); }
  inline void Swap(ConnectionAccepted* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionAccepted* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionAccepted* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ConnectionAccepted>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConnectionAccepted& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConnectionAccepted& from) { ConnectionAccepted::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConnectionAccepted* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.ConnectionAccepted"; }

 protected:
  explicit ConnectionAccepted(::google::protobuf::Arena* arena);
  ConnectionAccepted(::google::protobuf::Arena* arena, const ConnectionAccepted& from);
  ConnectionAccepted(::google::protobuf::Arena* arena, ConnectionAccepted&& from) noexcept
      : ConnectionAccepted(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionTokenFieldNumber = 2,
    kSpawnPositionFieldNumber = 4,
    kPlayerIdFieldNumber = 1,
    kServerTickFieldNumber = 3,
    kSpawnFloorFieldNumber = 5,
  };
  // string session_token = 2;
  void clear_session_token() ;
  const std::string& session_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_token(Arg_&& arg, Args_... args);
  std::string* mutable_session_token();
  PROTOBUF_NODISCARD std::string* release_session_token();
  void set_allocated_session_token(std::string* value);

  private:
  const std::string& _internal_session_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_token(
      const std::string& value);
  std::string* _internal_mutable_session_token();

  public:
  // .tower.game.Vec3 spawn_position = 4;
  bool has_spawn_position() const;
  void clear_spawn_position() ;
  const ::tower::game::Vec3& spawn_position() const;
  PROTOBUF_NODISCARD ::tower::game::Vec3* release_spawn_position();
  ::tower::game::Vec3* mutable_spawn_position();
  void set_allocated_spawn_position(::tower::game::Vec3* value);
  void unsafe_arena_set_allocated_spawn_position(::tower::game::Vec3* value);
  ::tower::game::Vec3* unsafe_arena_release_spawn_position();

  private:
  const ::tower::game::Vec3& _internal_spawn_position() const;
  ::tower::game::Vec3* _internal_mutable_spawn_position();

  public:
  // uint64 player_id = 1;
  void clear_player_id() ;
  ::uint64_t player_id() const;
  void set_player_id(::uint64_t value);

  private:
  ::uint64_t _internal_player_id() const;
  void _internal_set_player_id(::uint64_t value);

  public:
  // uint64 server_tick = 3;
  void clear_server_tick() ;
  ::uint64_t server_tick() const;
  void set_server_tick(::uint64_t value);

  private:
  ::uint64_t _internal_server_tick() const;
  void _internal_set_server_tick(::uint64_t value);

  public:
  // uint32 spawn_floor = 5;
  void clear_spawn_floor() ;
  ::uint32_t spawn_floor() const;
  void set_spawn_floor(::uint32_t value);

  private:
  ::uint32_t _internal_spawn_floor() const;
  void _internal_set_spawn_floor(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tower.game.ConnectionAccepted)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      51, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ConnectionAccepted_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConnectionAccepted& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr session_token_;
    ::tower::game::Vec3* spawn_position_;
    ::uint64_t player_id_;
    ::uint64_t server_tick_;
    ::uint32_t spawn_floor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class ChunkData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.ChunkData) */ {
 public:
  inline ChunkData() : ChunkData(nullptr) {}
  ~ChunkData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChunkData(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChunkData(const ChunkData& from) : ChunkData(nullptr, from) {}
  inline ChunkData(ChunkData&& from) noexcept
      : ChunkData(nullptr, std::move(from)) {}
  inline ChunkData& operator=(const ChunkData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkData& operator=(ChunkData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChunkData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChunkData* internal_default_instance() {
    return reinterpret_cast<const ChunkData*>(
        &_ChunkData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ChunkData& a, ChunkData& b) { a.Swap(&b); }
  inline void Swap(ChunkData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChunkData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ChunkData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChunkData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChunkData& from) { ChunkData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChunkData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.ChunkData"; }

 protected:
  explicit ChunkData(::google::protobuf::Arena* arena);
  ChunkData(::google::protobuf::Arena* arena, const ChunkData& from);
  ChunkData(::google::protobuf::Arena* arena, ChunkData&& from) noexcept
      : ChunkData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTilesFieldNumber = 3,
    kValidationHashFieldNumber = 4,
    kWorldOffsetFieldNumber = 8,
    kSeedFieldNumber = 1,
    kFloorIdFieldNumber = 2,
    kBiomeIdFieldNumber = 5,
    kWidthFieldNumber = 6,
    kHeightFieldNumber = 7,
  };
  // repeated .tower.game.FloorTileData tiles = 3;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;

  public:
  void clear_tiles() ;
  ::tower::game::FloorTileData* mutable_tiles(int index);
  ::google::protobuf::RepeatedPtrField<::tower::game::FloorTileData>* mutable_tiles();

  private:
  const ::google::protobuf::RepeatedPtrField<::tower::game::FloorTileData>& _internal_tiles() const;
  ::google::protobuf::RepeatedPtrField<::tower::game::FloorTileData>* _internal_mutable_tiles();
  public:
  const ::tower::game::FloorTileData& tiles(int index) const;
  ::tower::game::FloorTileData* add_tiles();
  const ::google::protobuf::RepeatedPtrField<::tower::game::FloorTileData>& tiles() const;
  // bytes validation_hash = 4;
  void clear_validation_hash() ;
  const std::string& validation_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validation_hash(Arg_&& arg, Args_... args);
  std::string* mutable_validation_hash();
  PROTOBUF_NODISCARD std::string* release_validation_hash();
  void set_allocated_validation_hash(std::string* value);

  private:
  const std::string& _internal_validation_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validation_hash(
      const std::string& value);
  std::string* _internal_mutable_validation_hash();

  public:
  // .tower.game.Vec3 world_offset = 8;
  bool has_world_offset() const;
  void clear_world_offset() ;
  const ::tower::game::Vec3& world_offset() const;
  PROTOBUF_NODISCARD ::tower::game::Vec3* release_world_offset();
  ::tower::game::Vec3* mutable_world_offset();
  void set_allocated_world_offset(::tower::game::Vec3* value);
  void unsafe_arena_set_allocated_world_offset(::tower::game::Vec3* value);
  ::tower::game::Vec3* unsafe_arena_release_world_offset();

  private:
  const ::tower::game::Vec3& _internal_world_offset() const;
  ::tower::game::Vec3* _internal_mutable_world_offset();

  public:
  // uint64 seed = 1;
  void clear_seed() ;
  ::uint64_t seed() const;
  void set_seed(::uint64_t value);

  private:
  ::uint64_t _internal_seed() const;
  void _internal_set_seed(::uint64_t value);

  public:
  // uint32 floor_id = 2;
  void clear_floor_id() ;
  ::uint32_t floor_id() const;
  void set_floor_id(::uint32_t value);

  private:
  ::uint32_t _internal_floor_id() const;
  void _internal_set_floor_id(::uint32_t value);

  public:
  // uint32 biome_id = 5;
  void clear_biome_id() ;
  ::uint32_t biome_id() const;
  void set_biome_id(::uint32_t value);

  private:
  ::uint32_t _internal_biome_id() const;
  void _internal_set_biome_id(::uint32_t value);

  public:
  // uint32 width = 6;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // uint32 height = 7;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tower.game.ChunkData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ChunkData_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ChunkData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tower::game::FloorTileData > tiles_;
    ::google::protobuf::internal::ArenaStringPtr validation_hash_;
    ::tower::game::Vec3* world_offset_;
    ::uint64_t seed_;
    ::uint32_t floor_id_;
    ::uint32_t biome_id_;
    ::uint32_t width_;
    ::uint32_t height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class WorldSnapshot final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.WorldSnapshot) */ {
 public:
  inline WorldSnapshot() : WorldSnapshot(nullptr) {}
  ~WorldSnapshot() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldSnapshot(
      ::google::protobuf::internal::ConstantInitialized);

  inline WorldSnapshot(const WorldSnapshot& from) : WorldSnapshot(nullptr, from) {}
  inline WorldSnapshot(WorldSnapshot&& from) noexcept
      : WorldSnapshot(nullptr, std::move(from)) {}
  inline WorldSnapshot& operator=(const WorldSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldSnapshot& operator=(WorldSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldSnapshot* internal_default_instance() {
    return reinterpret_cast<const WorldSnapshot*>(
        &_WorldSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(WorldSnapshot& a, WorldSnapshot& b) { a.Swap(&b); }
  inline void Swap(WorldSnapshot* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldSnapshot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldSnapshot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<WorldSnapshot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorldSnapshot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorldSnapshot& from) { WorldSnapshot::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorldSnapshot* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.WorldSnapshot"; }

 protected:
  explicit WorldSnapshot(::google::protobuf::Arena* arena);
  WorldSnapshot(::google::protobuf::Arena* arena, const WorldSnapshot& from);
  WorldSnapshot(::google::protobuf::Arena* arena, WorldSnapshot&& from) noexcept
      : WorldSnapshot(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayersFieldNumber = 4,
    kMonstersFieldNumber = 5,
    kTickFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kServerTimeMsFieldNumber = 3,
  };
  // repeated .tower.game.EntitySnapshot players = 4;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::tower::game::EntitySnapshot* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>* mutable_players();

  private:
  const ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>* _internal_mutable_players();
  public:
  const ::tower::game::EntitySnapshot& players(int index) const;
  ::tower::game::EntitySnapshot* add_players();
  const ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>& players() const;
  // repeated .tower.game.EntitySnapshot monsters = 5;
  int monsters_size() const;
  private:
  int _internal_monsters_size() const;

  public:
  void clear_monsters() ;
  ::tower::game::EntitySnapshot* mutable_monsters(int index);
  ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>* mutable_monsters();

  private:
  const ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>& _internal_monsters() const;
  ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>* _internal_mutable_monsters();
  public:
  const ::tower::game::EntitySnapshot& monsters(int index) const;
  ::tower::game::EntitySnapshot* add_monsters();
  const ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>& monsters() const;
  // uint64 tick = 1;
  void clear_tick() ;
  ::uint64_t tick() const;
  void set_tick(::uint64_t value);

  private:
  ::uint64_t _internal_tick() const;
  void _internal_set_tick(::uint64_t value);

  public:
  // uint64 timestamp = 2;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint32 server_time_ms = 3;
  void clear_server_time_ms() ;
  ::uint32_t server_time_ms() const;
  void set_server_time_ms(::uint32_t value);

  private:
  ::uint32_t _internal_server_time_ms() const;
  void _internal_set_server_time_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tower.game.WorldSnapshot)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_WorldSnapshot_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WorldSnapshot& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tower::game::EntitySnapshot > players_;
    ::google::protobuf::RepeatedPtrField< ::tower::game::EntitySnapshot > monsters_;
    ::uint64_t tick_;
    ::uint64_t timestamp_;
    ::uint32_t server_time_ms_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class ClientPacket final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.ClientPacket) */ {
 public:
  inline ClientPacket() : ClientPacket(nullptr) {}
  ~ClientPacket() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClientPacket(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClientPacket(const ClientPacket& from) : ClientPacket(nullptr, from) {}
  inline ClientPacket(ClientPacket&& from) noexcept
      : ClientPacket(nullptr, std::move(from)) {}
  inline ClientPacket& operator=(const ClientPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientPacket& operator=(ClientPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientPacket& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kInput = 1,
    kPing = 2,
    PAYLOAD_NOT_SET = 0,
  };
  static inline const ClientPacket* internal_default_instance() {
    return reinterpret_cast<const ClientPacket*>(
        &_ClientPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ClientPacket& a, ClientPacket& b) { a.Swap(&b); }
  inline void Swap(ClientPacket* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientPacket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientPacket* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ClientPacket>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClientPacket& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClientPacket& from) { ClientPacket::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClientPacket* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.ClientPacket"; }

 protected:
  explicit ClientPacket(::google::protobuf::Arena* arena);
  ClientPacket(::google::protobuf::Arena* arena, const ClientPacket& from);
  ClientPacket(::google::protobuf::Arena* arena, ClientPacket&& from) noexcept
      : ClientPacket(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputFieldNumber = 1,
    kPingFieldNumber = 2,
  };
  // .tower.game.PlayerInput input = 1;
  bool has_input() const;
  private:
  bool _internal_has_input() const;

  public:
  void clear_input() ;
  const ::tower::game::PlayerInput& input() const;
  PROTOBUF_NODISCARD ::tower::game::PlayerInput* release_input();
  ::tower::game::PlayerInput* mutable_input();
  void set_allocated_input(::tower::game::PlayerInput* value);
  void unsafe_arena_set_allocated_input(::tower::game::PlayerInput* value);
  ::tower::game::PlayerInput* unsafe_arena_release_input();

  private:
  const ::tower::game::PlayerInput& _internal_input() const;
  ::tower::game::PlayerInput* _internal_mutable_input();

  public:
  // bytes ping = 2;
  bool has_ping() const;
  void clear_ping() ;
  const std::string& ping() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ping(Arg_&& arg, Args_... args);
  std::string* mutable_ping();
  PROTOBUF_NODISCARD std::string* release_ping();
  void set_allocated_ping(std::string* value);

  private:
  const std::string& _internal_ping() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ping(
      const std::string& value);
  std::string* _internal_mutable_ping();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:tower.game.ClientPacket)
 private:
  class _Internal;
  void set_has_input();
  void set_has_ping();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ClientPacket_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClientPacket& from_msg);
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::tower::game::PlayerInput* input_;
      ::google::protobuf::internal::ArenaStringPtr ping_;
    } payload_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};
// -------------------------------------------------------------------

class ServerPacket final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tower.game.ServerPacket) */ {
 public:
  inline ServerPacket() : ServerPacket(nullptr) {}
  ~ServerPacket() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerPacket(
      ::google::protobuf::internal::ConstantInitialized);

  inline ServerPacket(const ServerPacket& from) : ServerPacket(nullptr, from) {}
  inline ServerPacket(ServerPacket&& from) noexcept
      : ServerPacket(nullptr, std::move(from)) {}
  inline ServerPacket& operator=(const ServerPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerPacket& operator=(ServerPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerPacket& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kSnapshot = 1,
    kChunkData = 2,
    kConnectionAccepted = 3,
    kPong = 4,
    PAYLOAD_NOT_SET = 0,
  };
  static inline const ServerPacket* internal_default_instance() {
    return reinterpret_cast<const ServerPacket*>(
        &_ServerPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ServerPacket& a, ServerPacket& b) { a.Swap(&b); }
  inline void Swap(ServerPacket* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerPacket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerPacket* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ServerPacket>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerPacket& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServerPacket& from) { ServerPacket::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ServerPacket* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "tower.game.ServerPacket"; }

 protected:
  explicit ServerPacket(::google::protobuf::Arena* arena);
  ServerPacket(::google::protobuf::Arena* arena, const ServerPacket& from);
  ServerPacket(::google::protobuf::Arena* arena, ServerPacket&& from) noexcept
      : ServerPacket(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSnapshotFieldNumber = 1,
    kChunkDataFieldNumber = 2,
    kConnectionAcceptedFieldNumber = 3,
    kPongFieldNumber = 4,
  };
  // .tower.game.WorldSnapshot snapshot = 1;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;

  public:
  void clear_snapshot() ;
  const ::tower::game::WorldSnapshot& snapshot() const;
  PROTOBUF_NODISCARD ::tower::game::WorldSnapshot* release_snapshot();
  ::tower::game::WorldSnapshot* mutable_snapshot();
  void set_allocated_snapshot(::tower::game::WorldSnapshot* value);
  void unsafe_arena_set_allocated_snapshot(::tower::game::WorldSnapshot* value);
  ::tower::game::WorldSnapshot* unsafe_arena_release_snapshot();

  private:
  const ::tower::game::WorldSnapshot& _internal_snapshot() const;
  ::tower::game::WorldSnapshot* _internal_mutable_snapshot();

  public:
  // .tower.game.ChunkData chunk_data = 2;
  bool has_chunk_data() const;
  private:
  bool _internal_has_chunk_data() const;

  public:
  void clear_chunk_data() ;
  const ::tower::game::ChunkData& chunk_data() const;
  PROTOBUF_NODISCARD ::tower::game::ChunkData* release_chunk_data();
  ::tower::game::ChunkData* mutable_chunk_data();
  void set_allocated_chunk_data(::tower::game::ChunkData* value);
  void unsafe_arena_set_allocated_chunk_data(::tower::game::ChunkData* value);
  ::tower::game::ChunkData* unsafe_arena_release_chunk_data();

  private:
  const ::tower::game::ChunkData& _internal_chunk_data() const;
  ::tower::game::ChunkData* _internal_mutable_chunk_data();

  public:
  // .tower.game.ConnectionAccepted connection_accepted = 3;
  bool has_connection_accepted() const;
  private:
  bool _internal_has_connection_accepted() const;

  public:
  void clear_connection_accepted() ;
  const ::tower::game::ConnectionAccepted& connection_accepted() const;
  PROTOBUF_NODISCARD ::tower::game::ConnectionAccepted* release_connection_accepted();
  ::tower::game::ConnectionAccepted* mutable_connection_accepted();
  void set_allocated_connection_accepted(::tower::game::ConnectionAccepted* value);
  void unsafe_arena_set_allocated_connection_accepted(::tower::game::ConnectionAccepted* value);
  ::tower::game::ConnectionAccepted* unsafe_arena_release_connection_accepted();

  private:
  const ::tower::game::ConnectionAccepted& _internal_connection_accepted() const;
  ::tower::game::ConnectionAccepted* _internal_mutable_connection_accepted();

  public:
  // bytes pong = 4;
  bool has_pong() const;
  void clear_pong() ;
  const std::string& pong() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pong(Arg_&& arg, Args_... args);
  std::string* mutable_pong();
  PROTOBUF_NODISCARD std::string* release_pong();
  void set_allocated_pong(std::string* value);

  private:
  const std::string& _internal_pong() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pong(
      const std::string& value);
  std::string* _internal_mutable_pong();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:tower.game.ServerPacket)
 private:
  class _Internal;
  void set_has_snapshot();
  void set_has_chunk_data();
  void set_has_connection_accepted();
  void set_has_pong();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ServerPacket_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ServerPacket& from_msg);
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::tower::game::WorldSnapshot* snapshot_;
      ::tower::game::ChunkData* chunk_data_;
      ::tower::game::ConnectionAccepted* connection_accepted_;
      ::google::protobuf::internal::ArenaStringPtr pong_;
    } payload_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fstate_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vec3

// float x = 1;
inline void Vec3::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:tower.game.Vec3.x)
  return _internal_x();
}
inline void Vec3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:tower.game.Vec3.x)
}
inline float Vec3::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vec3::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Vec3::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:tower.game.Vec3.y)
  return _internal_y();
}
inline void Vec3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:tower.game.Vec3.y)
}
inline float Vec3::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vec3::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Vec3::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:tower.game.Vec3.z)
  return _internal_z();
}
inline void Vec3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:tower.game.Vec3.z)
}
inline float Vec3::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vec3::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Rotation

// float pitch = 1;
inline void Rotation::clear_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pitch_ = 0;
}
inline float Rotation::pitch() const {
  // @@protoc_insertion_point(field_get:tower.game.Rotation.pitch)
  return _internal_pitch();
}
inline void Rotation::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:tower.game.Rotation.pitch)
}
inline float Rotation::_internal_pitch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pitch_;
}
inline void Rotation::_internal_set_pitch(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pitch_ = value;
}

// float yaw = 2;
inline void Rotation::clear_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yaw_ = 0;
}
inline float Rotation::yaw() const {
  // @@protoc_insertion_point(field_get:tower.game.Rotation.yaw)
  return _internal_yaw();
}
inline void Rotation::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:tower.game.Rotation.yaw)
}
inline float Rotation::_internal_yaw() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.yaw_;
}
inline void Rotation::_internal_set_yaw(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yaw_ = value;
}

// float roll = 3;
inline void Rotation::clear_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.roll_ = 0;
}
inline float Rotation::roll() const {
  // @@protoc_insertion_point(field_get:tower.game.Rotation.roll)
  return _internal_roll();
}
inline void Rotation::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:tower.game.Rotation.roll)
}
inline float Rotation::_internal_roll() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.roll_;
}
inline void Rotation::_internal_set_roll(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.roll_ = value;
}

// -------------------------------------------------------------------

// Velocity

// float x = 1;
inline void Velocity::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float Velocity::x() const {
  // @@protoc_insertion_point(field_get:tower.game.Velocity.x)
  return _internal_x();
}
inline void Velocity::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:tower.game.Velocity.x)
}
inline float Velocity::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Velocity::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Velocity::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float Velocity::y() const {
  // @@protoc_insertion_point(field_get:tower.game.Velocity.y)
  return _internal_y();
}
inline void Velocity::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:tower.game.Velocity.y)
}
inline float Velocity::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Velocity::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Velocity::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float Velocity::z() const {
  // @@protoc_insertion_point(field_get:tower.game.Velocity.z)
  return _internal_z();
}
inline void Velocity::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:tower.game.Velocity.z)
}
inline float Velocity::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Velocity::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// PlayerData

// uint64 id = 1;
inline void PlayerData::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerData::id() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.id)
  return _internal_id();
}
inline void PlayerData::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerData.id)
}
inline ::uint64_t PlayerData::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void PlayerData::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .tower.game.Vec3 position = 2;
inline bool PlayerData::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void PlayerData::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tower::game::Vec3& PlayerData::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Vec3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Vec3&>(::tower::game::_Vec3_default_instance_);
}
inline const ::tower::game::Vec3& PlayerData::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.position)
  return _internal_position();
}
inline void PlayerData::unsafe_arena_set_allocated_position(::tower::game::Vec3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::tower::game::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.PlayerData.position)
}
inline ::tower::game::Vec3* PlayerData::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tower::game::Vec3* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Vec3* PlayerData::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.PlayerData.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tower::game::Vec3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::tower::game::Vec3* PlayerData::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Vec3>(GetArena());
    _impl_.position_ = reinterpret_cast<::tower::game::Vec3*>(p);
  }
  return _impl_.position_;
}
inline ::tower::game::Vec3* PlayerData::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tower::game::Vec3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:tower.game.PlayerData.position)
  return _msg;
}
inline void PlayerData::set_allocated_position(::tower::game::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::tower::game::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.PlayerData.position)
}

// .tower.game.Velocity velocity = 3;
inline bool PlayerData::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void PlayerData::clear_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tower::game::Velocity& PlayerData::_internal_velocity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Velocity* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Velocity&>(::tower::game::_Velocity_default_instance_);
}
inline const ::tower::game::Velocity& PlayerData::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.velocity)
  return _internal_velocity();
}
inline void PlayerData::unsafe_arena_set_allocated_velocity(::tower::game::Velocity* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::tower::game::Velocity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.PlayerData.velocity)
}
inline ::tower::game::Velocity* PlayerData::release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tower::game::Velocity* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Velocity* PlayerData::unsafe_arena_release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.PlayerData.velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tower::game::Velocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::tower::game::Velocity* PlayerData::_internal_mutable_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Velocity>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::tower::game::Velocity*>(p);
  }
  return _impl_.velocity_;
}
inline ::tower::game::Velocity* PlayerData::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tower::game::Velocity* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:tower.game.PlayerData.velocity)
  return _msg;
}
inline void PlayerData::set_allocated_velocity(::tower::game::Velocity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.velocity_ = reinterpret_cast<::tower::game::Velocity*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.PlayerData.velocity)
}

// .tower.game.Rotation rotation = 4;
inline bool PlayerData::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void PlayerData::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::tower::game::Rotation& PlayerData::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Rotation* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Rotation&>(::tower::game::_Rotation_default_instance_);
}
inline const ::tower::game::Rotation& PlayerData::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.rotation)
  return _internal_rotation();
}
inline void PlayerData::unsafe_arena_set_allocated_rotation(::tower::game::Rotation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::tower::game::Rotation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.PlayerData.rotation)
}
inline ::tower::game::Rotation* PlayerData::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tower::game::Rotation* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Rotation* PlayerData::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.PlayerData.rotation)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tower::game::Rotation* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::tower::game::Rotation* PlayerData::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Rotation>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::tower::game::Rotation*>(p);
  }
  return _impl_.rotation_;
}
inline ::tower::game::Rotation* PlayerData::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::tower::game::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:tower.game.PlayerData.rotation)
  return _msg;
}
inline void PlayerData::set_allocated_rotation(::tower::game::Rotation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.rotation_ = reinterpret_cast<::tower::game::Rotation*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.PlayerData.rotation)
}

// float health = 5;
inline void PlayerData::clear_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = 0;
}
inline float PlayerData::health() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.health)
  return _internal_health();
}
inline void PlayerData::set_health(float value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerData.health)
}
inline float PlayerData::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_;
}
inline void PlayerData::_internal_set_health(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = value;
}

// float max_health = 6;
inline void PlayerData::clear_max_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_health_ = 0;
}
inline float PlayerData::max_health() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.max_health)
  return _internal_max_health();
}
inline void PlayerData::set_max_health(float value) {
  _internal_set_max_health(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerData.max_health)
}
inline float PlayerData::_internal_max_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_health_;
}
inline void PlayerData::_internal_set_max_health(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_health_ = value;
}

// uint32 current_floor = 7;
inline void PlayerData::clear_current_floor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_floor_ = 0u;
}
inline ::uint32_t PlayerData::current_floor() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.current_floor)
  return _internal_current_floor();
}
inline void PlayerData::set_current_floor(::uint32_t value) {
  _internal_set_current_floor(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerData.current_floor)
}
inline ::uint32_t PlayerData::_internal_current_floor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_floor_;
}
inline void PlayerData::_internal_set_current_floor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_floor_ = value;
}

// string player_name = 8;
inline void PlayerData::clear_player_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_name_.ClearToEmpty();
}
inline const std::string& PlayerData::player_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.player_name)
  return _internal_player_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerData::set_player_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tower.game.PlayerData.player_name)
}
inline std::string* PlayerData::mutable_player_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_name();
  // @@protoc_insertion_point(field_mutable:tower.game.PlayerData.player_name)
  return _s;
}
inline const std::string& PlayerData::_internal_player_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_name_.Get();
}
inline void PlayerData::_internal_set_player_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_name_.Set(value, GetArena());
}
inline std::string* PlayerData::_internal_mutable_player_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.player_name_.Mutable( GetArena());
}
inline std::string* PlayerData::release_player_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.PlayerData.player_name)
  return _impl_.player_name_.Release();
}
inline void PlayerData::set_allocated_player_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_name_.IsDefault()) {
          _impl_.player_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tower.game.PlayerData.player_name)
}

// uint32 level = 9;
inline void PlayerData::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0u;
}
inline ::uint32_t PlayerData::level() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.level)
  return _internal_level();
}
inline void PlayerData::set_level(::uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerData.level)
}
inline ::uint32_t PlayerData::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_;
}
inline void PlayerData::_internal_set_level(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// bool in_combat = 10;
inline void PlayerData::clear_in_combat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_combat_ = false;
}
inline bool PlayerData::in_combat() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.in_combat)
  return _internal_in_combat();
}
inline void PlayerData::set_in_combat(bool value) {
  _internal_set_in_combat(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerData.in_combat)
}
inline bool PlayerData::_internal_in_combat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_combat_;
}
inline void PlayerData::_internal_set_in_combat(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_combat_ = value;
}

// uint64 target_entity = 11;
inline void PlayerData::clear_target_entity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_entity_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerData::target_entity() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.target_entity)
  return _internal_target_entity();
}
inline void PlayerData::set_target_entity(::uint64_t value) {
  _internal_set_target_entity(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerData.target_entity)
}
inline ::uint64_t PlayerData::_internal_target_entity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_entity_;
}
inline void PlayerData::_internal_set_target_entity(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_entity_ = value;
}

// bool is_grounded = 12;
inline void PlayerData::clear_is_grounded() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_grounded_ = false;
}
inline bool PlayerData::is_grounded() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.is_grounded)
  return _internal_is_grounded();
}
inline void PlayerData::set_is_grounded(bool value) {
  _internal_set_is_grounded(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerData.is_grounded)
}
inline bool PlayerData::_internal_is_grounded() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_grounded_;
}
inline void PlayerData::_internal_set_is_grounded(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_grounded_ = value;
}

// bool is_flying = 13;
inline void PlayerData::clear_is_flying() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_flying_ = false;
}
inline bool PlayerData::is_flying() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.is_flying)
  return _internal_is_flying();
}
inline void PlayerData::set_is_flying(bool value) {
  _internal_set_is_flying(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerData.is_flying)
}
inline bool PlayerData::_internal_is_flying() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_flying_;
}
inline void PlayerData::_internal_set_is_flying(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_flying_ = value;
}

// bool is_dashing = 14;
inline void PlayerData::clear_is_dashing() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_dashing_ = false;
}
inline bool PlayerData::is_dashing() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerData.is_dashing)
  return _internal_is_dashing();
}
inline void PlayerData::set_is_dashing(bool value) {
  _internal_set_is_dashing(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerData.is_dashing)
}
inline bool PlayerData::_internal_is_dashing() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_dashing_;
}
inline void PlayerData::_internal_set_is_dashing(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_dashing_ = value;
}

// -------------------------------------------------------------------

// MonsterData

// uint64 id = 1;
inline void MonsterData::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t MonsterData::id() const {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.id)
  return _internal_id();
}
inline void MonsterData::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tower.game.MonsterData.id)
}
inline ::uint64_t MonsterData::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void MonsterData::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// string monster_type = 2;
inline void MonsterData::clear_monster_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_type_.ClearToEmpty();
}
inline const std::string& MonsterData::monster_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.monster_type)
  return _internal_monster_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MonsterData::set_monster_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tower.game.MonsterData.monster_type)
}
inline std::string* MonsterData::mutable_monster_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_monster_type();
  // @@protoc_insertion_point(field_mutable:tower.game.MonsterData.monster_type)
  return _s;
}
inline const std::string& MonsterData::_internal_monster_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monster_type_.Get();
}
inline void MonsterData::_internal_set_monster_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_type_.Set(value, GetArena());
}
inline std::string* MonsterData::_internal_mutable_monster_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.monster_type_.Mutable( GetArena());
}
inline std::string* MonsterData::release_monster_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.MonsterData.monster_type)
  return _impl_.monster_type_.Release();
}
inline void MonsterData::set_allocated_monster_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.monster_type_.IsDefault()) {
          _impl_.monster_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tower.game.MonsterData.monster_type)
}

// .tower.game.Vec3 position = 3;
inline bool MonsterData::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void MonsterData::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tower::game::Vec3& MonsterData::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Vec3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Vec3&>(::tower::game::_Vec3_default_instance_);
}
inline const ::tower::game::Vec3& MonsterData::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.position)
  return _internal_position();
}
inline void MonsterData::unsafe_arena_set_allocated_position(::tower::game::Vec3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::tower::game::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.MonsterData.position)
}
inline ::tower::game::Vec3* MonsterData::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tower::game::Vec3* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Vec3* MonsterData::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.MonsterData.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tower::game::Vec3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::tower::game::Vec3* MonsterData::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Vec3>(GetArena());
    _impl_.position_ = reinterpret_cast<::tower::game::Vec3*>(p);
  }
  return _impl_.position_;
}
inline ::tower::game::Vec3* MonsterData::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tower::game::Vec3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:tower.game.MonsterData.position)
  return _msg;
}
inline void MonsterData::set_allocated_position(::tower::game::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::tower::game::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.MonsterData.position)
}

// .tower.game.Velocity velocity = 4;
inline bool MonsterData::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void MonsterData::clear_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tower::game::Velocity& MonsterData::_internal_velocity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Velocity* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Velocity&>(::tower::game::_Velocity_default_instance_);
}
inline const ::tower::game::Velocity& MonsterData::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.velocity)
  return _internal_velocity();
}
inline void MonsterData::unsafe_arena_set_allocated_velocity(::tower::game::Velocity* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::tower::game::Velocity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.MonsterData.velocity)
}
inline ::tower::game::Velocity* MonsterData::release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tower::game::Velocity* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Velocity* MonsterData::unsafe_arena_release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.MonsterData.velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tower::game::Velocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::tower::game::Velocity* MonsterData::_internal_mutable_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Velocity>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::tower::game::Velocity*>(p);
  }
  return _impl_.velocity_;
}
inline ::tower::game::Velocity* MonsterData::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tower::game::Velocity* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:tower.game.MonsterData.velocity)
  return _msg;
}
inline void MonsterData::set_allocated_velocity(::tower::game::Velocity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.velocity_ = reinterpret_cast<::tower::game::Velocity*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.MonsterData.velocity)
}

// .tower.game.Rotation rotation = 5;
inline bool MonsterData::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void MonsterData::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::tower::game::Rotation& MonsterData::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Rotation* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Rotation&>(::tower::game::_Rotation_default_instance_);
}
inline const ::tower::game::Rotation& MonsterData::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.rotation)
  return _internal_rotation();
}
inline void MonsterData::unsafe_arena_set_allocated_rotation(::tower::game::Rotation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::tower::game::Rotation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.MonsterData.rotation)
}
inline ::tower::game::Rotation* MonsterData::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tower::game::Rotation* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Rotation* MonsterData::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.MonsterData.rotation)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tower::game::Rotation* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::tower::game::Rotation* MonsterData::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Rotation>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::tower::game::Rotation*>(p);
  }
  return _impl_.rotation_;
}
inline ::tower::game::Rotation* MonsterData::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::tower::game::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:tower.game.MonsterData.rotation)
  return _msg;
}
inline void MonsterData::set_allocated_rotation(::tower::game::Rotation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.rotation_ = reinterpret_cast<::tower::game::Rotation*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.MonsterData.rotation)
}

// float health = 6;
inline void MonsterData::clear_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = 0;
}
inline float MonsterData::health() const {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.health)
  return _internal_health();
}
inline void MonsterData::set_health(float value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:tower.game.MonsterData.health)
}
inline float MonsterData::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_;
}
inline void MonsterData::_internal_set_health(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = value;
}

// float max_health = 7;
inline void MonsterData::clear_max_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_health_ = 0;
}
inline float MonsterData::max_health() const {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.max_health)
  return _internal_max_health();
}
inline void MonsterData::set_max_health(float value) {
  _internal_set_max_health(value);
  // @@protoc_insertion_point(field_set:tower.game.MonsterData.max_health)
}
inline float MonsterData::_internal_max_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_health_;
}
inline void MonsterData::_internal_set_max_health(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_health_ = value;
}

// uint32 floor_id = 8;
inline void MonsterData::clear_floor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.floor_id_ = 0u;
}
inline ::uint32_t MonsterData::floor_id() const {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.floor_id)
  return _internal_floor_id();
}
inline void MonsterData::set_floor_id(::uint32_t value) {
  _internal_set_floor_id(value);
  // @@protoc_insertion_point(field_set:tower.game.MonsterData.floor_id)
}
inline ::uint32_t MonsterData::_internal_floor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.floor_id_;
}
inline void MonsterData::_internal_set_floor_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.floor_id_ = value;
}

// string ai_state = 9;
inline void MonsterData::clear_ai_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ai_state_.ClearToEmpty();
}
inline const std::string& MonsterData::ai_state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.ai_state)
  return _internal_ai_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MonsterData::set_ai_state(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ai_state_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tower.game.MonsterData.ai_state)
}
inline std::string* MonsterData::mutable_ai_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ai_state();
  // @@protoc_insertion_point(field_mutable:tower.game.MonsterData.ai_state)
  return _s;
}
inline const std::string& MonsterData::_internal_ai_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ai_state_.Get();
}
inline void MonsterData::_internal_set_ai_state(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ai_state_.Set(value, GetArena());
}
inline std::string* MonsterData::_internal_mutable_ai_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ai_state_.Mutable( GetArena());
}
inline std::string* MonsterData::release_ai_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.MonsterData.ai_state)
  return _impl_.ai_state_.Release();
}
inline void MonsterData::set_allocated_ai_state(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ai_state_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ai_state_.IsDefault()) {
          _impl_.ai_state_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tower.game.MonsterData.ai_state)
}

// uint64 target_player = 10;
inline void MonsterData::clear_target_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_player_ = ::uint64_t{0u};
}
inline ::uint64_t MonsterData::target_player() const {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.target_player)
  return _internal_target_player();
}
inline void MonsterData::set_target_player(::uint64_t value) {
  _internal_set_target_player(value);
  // @@protoc_insertion_point(field_set:tower.game.MonsterData.target_player)
}
inline ::uint64_t MonsterData::_internal_target_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_player_;
}
inline void MonsterData::_internal_set_target_player(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_player_ = value;
}

// float attack_damage = 11;
inline void MonsterData::clear_attack_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_damage_ = 0;
}
inline float MonsterData::attack_damage() const {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.attack_damage)
  return _internal_attack_damage();
}
inline void MonsterData::set_attack_damage(float value) {
  _internal_set_attack_damage(value);
  // @@protoc_insertion_point(field_set:tower.game.MonsterData.attack_damage)
}
inline float MonsterData::_internal_attack_damage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attack_damage_;
}
inline void MonsterData::_internal_set_attack_damage(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_damage_ = value;
}

// float attack_range = 12;
inline void MonsterData::clear_attack_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_range_ = 0;
}
inline float MonsterData::attack_range() const {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.attack_range)
  return _internal_attack_range();
}
inline void MonsterData::set_attack_range(float value) {
  _internal_set_attack_range(value);
  // @@protoc_insertion_point(field_set:tower.game.MonsterData.attack_range)
}
inline float MonsterData::_internal_attack_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attack_range_;
}
inline void MonsterData::_internal_set_attack_range(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_range_ = value;
}

// float movement_speed = 13;
inline void MonsterData::clear_movement_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_speed_ = 0;
}
inline float MonsterData::movement_speed() const {
  // @@protoc_insertion_point(field_get:tower.game.MonsterData.movement_speed)
  return _internal_movement_speed();
}
inline void MonsterData::set_movement_speed(float value) {
  _internal_set_movement_speed(value);
  // @@protoc_insertion_point(field_set:tower.game.MonsterData.movement_speed)
}
inline float MonsterData::_internal_movement_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_speed_;
}
inline void MonsterData::_internal_set_movement_speed(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_speed_ = value;
}

// -------------------------------------------------------------------

// FloorTileData

// uint32 tile_type = 1;
inline void FloorTileData::clear_tile_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tile_type_ = 0u;
}
inline ::uint32_t FloorTileData::tile_type() const {
  // @@protoc_insertion_point(field_get:tower.game.FloorTileData.tile_type)
  return _internal_tile_type();
}
inline void FloorTileData::set_tile_type(::uint32_t value) {
  _internal_set_tile_type(value);
  // @@protoc_insertion_point(field_set:tower.game.FloorTileData.tile_type)
}
inline ::uint32_t FloorTileData::_internal_tile_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tile_type_;
}
inline void FloorTileData::_internal_set_tile_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tile_type_ = value;
}

// int32 grid_x = 2;
inline void FloorTileData::clear_grid_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_x_ = 0;
}
inline ::int32_t FloorTileData::grid_x() const {
  // @@protoc_insertion_point(field_get:tower.game.FloorTileData.grid_x)
  return _internal_grid_x();
}
inline void FloorTileData::set_grid_x(::int32_t value) {
  _internal_set_grid_x(value);
  // @@protoc_insertion_point(field_set:tower.game.FloorTileData.grid_x)
}
inline ::int32_t FloorTileData::_internal_grid_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.grid_x_;
}
inline void FloorTileData::_internal_set_grid_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_x_ = value;
}

// int32 grid_y = 3;
inline void FloorTileData::clear_grid_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_y_ = 0;
}
inline ::int32_t FloorTileData::grid_y() const {
  // @@protoc_insertion_point(field_get:tower.game.FloorTileData.grid_y)
  return _internal_grid_y();
}
inline void FloorTileData::set_grid_y(::int32_t value) {
  _internal_set_grid_y(value);
  // @@protoc_insertion_point(field_set:tower.game.FloorTileData.grid_y)
}
inline ::int32_t FloorTileData::_internal_grid_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.grid_y_;
}
inline void FloorTileData::_internal_set_grid_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_y_ = value;
}

// uint32 biome_id = 4;
inline void FloorTileData::clear_biome_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.biome_id_ = 0u;
}
inline ::uint32_t FloorTileData::biome_id() const {
  // @@protoc_insertion_point(field_get:tower.game.FloorTileData.biome_id)
  return _internal_biome_id();
}
inline void FloorTileData::set_biome_id(::uint32_t value) {
  _internal_set_biome_id(value);
  // @@protoc_insertion_point(field_set:tower.game.FloorTileData.biome_id)
}
inline ::uint32_t FloorTileData::_internal_biome_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.biome_id_;
}
inline void FloorTileData::_internal_set_biome_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.biome_id_ = value;
}

// bool is_walkable = 5;
inline void FloorTileData::clear_is_walkable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_walkable_ = false;
}
inline bool FloorTileData::is_walkable() const {
  // @@protoc_insertion_point(field_get:tower.game.FloorTileData.is_walkable)
  return _internal_is_walkable();
}
inline void FloorTileData::set_is_walkable(bool value) {
  _internal_set_is_walkable(value);
  // @@protoc_insertion_point(field_set:tower.game.FloorTileData.is_walkable)
}
inline bool FloorTileData::_internal_is_walkable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_walkable_;
}
inline void FloorTileData::_internal_set_is_walkable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_walkable_ = value;
}

// bool has_collision = 6;
inline void FloorTileData::clear_has_collision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_collision_ = false;
}
inline bool FloorTileData::has_collision() const {
  // @@protoc_insertion_point(field_get:tower.game.FloorTileData.has_collision)
  return _internal_has_collision();
}
inline void FloorTileData::set_has_collision(bool value) {
  _internal_set_has_collision(value);
  // @@protoc_insertion_point(field_set:tower.game.FloorTileData.has_collision)
}
inline bool FloorTileData::_internal_has_collision() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_collision_;
}
inline void FloorTileData::_internal_set_has_collision(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_collision_ = value;
}

// -------------------------------------------------------------------

// ChunkData

// uint64 seed = 1;
inline void ChunkData::clear_seed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seed_ = ::uint64_t{0u};
}
inline ::uint64_t ChunkData::seed() const {
  // @@protoc_insertion_point(field_get:tower.game.ChunkData.seed)
  return _internal_seed();
}
inline void ChunkData::set_seed(::uint64_t value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:tower.game.ChunkData.seed)
}
inline ::uint64_t ChunkData::_internal_seed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.seed_;
}
inline void ChunkData::_internal_set_seed(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seed_ = value;
}

// uint32 floor_id = 2;
inline void ChunkData::clear_floor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.floor_id_ = 0u;
}
inline ::uint32_t ChunkData::floor_id() const {
  // @@protoc_insertion_point(field_get:tower.game.ChunkData.floor_id)
  return _internal_floor_id();
}
inline void ChunkData::set_floor_id(::uint32_t value) {
  _internal_set_floor_id(value);
  // @@protoc_insertion_point(field_set:tower.game.ChunkData.floor_id)
}
inline ::uint32_t ChunkData::_internal_floor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.floor_id_;
}
inline void ChunkData::_internal_set_floor_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.floor_id_ = value;
}

// repeated .tower.game.FloorTileData tiles = 3;
inline int ChunkData::_internal_tiles_size() const {
  return _internal_tiles().size();
}
inline int ChunkData::tiles_size() const {
  return _internal_tiles_size();
}
inline void ChunkData::clear_tiles() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tiles_.Clear();
}
inline ::tower::game::FloorTileData* ChunkData::mutable_tiles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tower.game.ChunkData.tiles)
  return _internal_mutable_tiles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tower::game::FloorTileData>* ChunkData::mutable_tiles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tower.game.ChunkData.tiles)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tiles();
}
inline const ::tower::game::FloorTileData& ChunkData::tiles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.ChunkData.tiles)
  return _internal_tiles().Get(index);
}
inline ::tower::game::FloorTileData* ChunkData::add_tiles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tower::game::FloorTileData* _add = _internal_mutable_tiles()->Add();
  // @@protoc_insertion_point(field_add:tower.game.ChunkData.tiles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tower::game::FloorTileData>& ChunkData::tiles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tower.game.ChunkData.tiles)
  return _internal_tiles();
}
inline const ::google::protobuf::RepeatedPtrField<::tower::game::FloorTileData>&
ChunkData::_internal_tiles() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tiles_;
}
inline ::google::protobuf::RepeatedPtrField<::tower::game::FloorTileData>*
ChunkData::_internal_mutable_tiles() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tiles_;
}

// bytes validation_hash = 4;
inline void ChunkData::clear_validation_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_hash_.ClearToEmpty();
}
inline const std::string& ChunkData::validation_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.ChunkData.validation_hash)
  return _internal_validation_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChunkData::set_validation_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tower.game.ChunkData.validation_hash)
}
inline std::string* ChunkData::mutable_validation_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_validation_hash();
  // @@protoc_insertion_point(field_mutable:tower.game.ChunkData.validation_hash)
  return _s;
}
inline const std::string& ChunkData::_internal_validation_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validation_hash_.Get();
}
inline void ChunkData::_internal_set_validation_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_hash_.Set(value, GetArena());
}
inline std::string* ChunkData::_internal_mutable_validation_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.validation_hash_.Mutable( GetArena());
}
inline std::string* ChunkData::release_validation_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.ChunkData.validation_hash)
  return _impl_.validation_hash_.Release();
}
inline void ChunkData::set_allocated_validation_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validation_hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validation_hash_.IsDefault()) {
          _impl_.validation_hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tower.game.ChunkData.validation_hash)
}

// uint32 biome_id = 5;
inline void ChunkData::clear_biome_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.biome_id_ = 0u;
}
inline ::uint32_t ChunkData::biome_id() const {
  // @@protoc_insertion_point(field_get:tower.game.ChunkData.biome_id)
  return _internal_biome_id();
}
inline void ChunkData::set_biome_id(::uint32_t value) {
  _internal_set_biome_id(value);
  // @@protoc_insertion_point(field_set:tower.game.ChunkData.biome_id)
}
inline ::uint32_t ChunkData::_internal_biome_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.biome_id_;
}
inline void ChunkData::_internal_set_biome_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.biome_id_ = value;
}

// uint32 width = 6;
inline void ChunkData::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0u;
}
inline ::uint32_t ChunkData::width() const {
  // @@protoc_insertion_point(field_get:tower.game.ChunkData.width)
  return _internal_width();
}
inline void ChunkData::set_width(::uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:tower.game.ChunkData.width)
}
inline ::uint32_t ChunkData::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void ChunkData::_internal_set_width(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// uint32 height = 7;
inline void ChunkData::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0u;
}
inline ::uint32_t ChunkData::height() const {
  // @@protoc_insertion_point(field_get:tower.game.ChunkData.height)
  return _internal_height();
}
inline void ChunkData::set_height(::uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tower.game.ChunkData.height)
}
inline ::uint32_t ChunkData::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void ChunkData::_internal_set_height(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// .tower.game.Vec3 world_offset = 8;
inline bool ChunkData::has_world_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.world_offset_ != nullptr);
  return value;
}
inline void ChunkData::clear_world_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.world_offset_ != nullptr) _impl_.world_offset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tower::game::Vec3& ChunkData::_internal_world_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Vec3* p = _impl_.world_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Vec3&>(::tower::game::_Vec3_default_instance_);
}
inline const ::tower::game::Vec3& ChunkData::world_offset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.ChunkData.world_offset)
  return _internal_world_offset();
}
inline void ChunkData::unsafe_arena_set_allocated_world_offset(::tower::game::Vec3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.world_offset_);
  }
  _impl_.world_offset_ = reinterpret_cast<::tower::game::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.ChunkData.world_offset)
}
inline ::tower::game::Vec3* ChunkData::release_world_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tower::game::Vec3* released = _impl_.world_offset_;
  _impl_.world_offset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Vec3* ChunkData::unsafe_arena_release_world_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.ChunkData.world_offset)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tower::game::Vec3* temp = _impl_.world_offset_;
  _impl_.world_offset_ = nullptr;
  return temp;
}
inline ::tower::game::Vec3* ChunkData::_internal_mutable_world_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.world_offset_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Vec3>(GetArena());
    _impl_.world_offset_ = reinterpret_cast<::tower::game::Vec3*>(p);
  }
  return _impl_.world_offset_;
}
inline ::tower::game::Vec3* ChunkData::mutable_world_offset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tower::game::Vec3* _msg = _internal_mutable_world_offset();
  // @@protoc_insertion_point(field_mutable:tower.game.ChunkData.world_offset)
  return _msg;
}
inline void ChunkData::set_allocated_world_offset(::tower::game::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.world_offset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.world_offset_ = reinterpret_cast<::tower::game::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.ChunkData.world_offset)
}

// -------------------------------------------------------------------

// EntitySnapshot

// uint64 entity_id = 1;
inline void EntitySnapshot::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_ = ::uint64_t{0u};
}
inline ::uint64_t EntitySnapshot::entity_id() const {
  // @@protoc_insertion_point(field_get:tower.game.EntitySnapshot.entity_id)
  return _internal_entity_id();
}
inline void EntitySnapshot::set_entity_id(::uint64_t value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:tower.game.EntitySnapshot.entity_id)
}
inline ::uint64_t EntitySnapshot::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_;
}
inline void EntitySnapshot::_internal_set_entity_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_ = value;
}

// uint32 changed_fields = 2;
inline void EntitySnapshot::clear_changed_fields() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.changed_fields_ = 0u;
}
inline ::uint32_t EntitySnapshot::changed_fields() const {
  // @@protoc_insertion_point(field_get:tower.game.EntitySnapshot.changed_fields)
  return _internal_changed_fields();
}
inline void EntitySnapshot::set_changed_fields(::uint32_t value) {
  _internal_set_changed_fields(value);
  // @@protoc_insertion_point(field_set:tower.game.EntitySnapshot.changed_fields)
}
inline ::uint32_t EntitySnapshot::_internal_changed_fields() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.changed_fields_;
}
inline void EntitySnapshot::_internal_set_changed_fields(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.changed_fields_ = value;
}

// optional .tower.game.Vec3 position = 3;
inline bool EntitySnapshot::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void EntitySnapshot::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tower::game::Vec3& EntitySnapshot::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Vec3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Vec3&>(::tower::game::_Vec3_default_instance_);
}
inline const ::tower::game::Vec3& EntitySnapshot::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.EntitySnapshot.position)
  return _internal_position();
}
inline void EntitySnapshot::unsafe_arena_set_allocated_position(::tower::game::Vec3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::tower::game::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.EntitySnapshot.position)
}
inline ::tower::game::Vec3* EntitySnapshot::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tower::game::Vec3* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Vec3* EntitySnapshot::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.EntitySnapshot.position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tower::game::Vec3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::tower::game::Vec3* EntitySnapshot::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Vec3>(GetArena());
    _impl_.position_ = reinterpret_cast<::tower::game::Vec3*>(p);
  }
  return _impl_.position_;
}
inline ::tower::game::Vec3* EntitySnapshot::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tower::game::Vec3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:tower.game.EntitySnapshot.position)
  return _msg;
}
inline void EntitySnapshot::set_allocated_position(::tower::game::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_ = reinterpret_cast<::tower::game::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.EntitySnapshot.position)
}

// optional .tower.game.Velocity velocity = 4;
inline bool EntitySnapshot::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void EntitySnapshot::clear_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::tower::game::Velocity& EntitySnapshot::_internal_velocity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Velocity* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Velocity&>(::tower::game::_Velocity_default_instance_);
}
inline const ::tower::game::Velocity& EntitySnapshot::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.EntitySnapshot.velocity)
  return _internal_velocity();
}
inline void EntitySnapshot::unsafe_arena_set_allocated_velocity(::tower::game::Velocity* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::tower::game::Velocity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.EntitySnapshot.velocity)
}
inline ::tower::game::Velocity* EntitySnapshot::release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tower::game::Velocity* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Velocity* EntitySnapshot::unsafe_arena_release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.EntitySnapshot.velocity)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tower::game::Velocity* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::tower::game::Velocity* EntitySnapshot::_internal_mutable_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Velocity>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::tower::game::Velocity*>(p);
  }
  return _impl_.velocity_;
}
inline ::tower::game::Velocity* EntitySnapshot::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::tower::game::Velocity* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:tower.game.EntitySnapshot.velocity)
  return _msg;
}
inline void EntitySnapshot::set_allocated_velocity(::tower::game::Velocity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.velocity_ = reinterpret_cast<::tower::game::Velocity*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.EntitySnapshot.velocity)
}

// optional .tower.game.Rotation rotation = 5;
inline bool EntitySnapshot::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void EntitySnapshot::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::tower::game::Rotation& EntitySnapshot::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Rotation* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Rotation&>(::tower::game::_Rotation_default_instance_);
}
inline const ::tower::game::Rotation& EntitySnapshot::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.EntitySnapshot.rotation)
  return _internal_rotation();
}
inline void EntitySnapshot::unsafe_arena_set_allocated_rotation(::tower::game::Rotation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::tower::game::Rotation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.EntitySnapshot.rotation)
}
inline ::tower::game::Rotation* EntitySnapshot::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::tower::game::Rotation* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Rotation* EntitySnapshot::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.EntitySnapshot.rotation)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::tower::game::Rotation* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::tower::game::Rotation* EntitySnapshot::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Rotation>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::tower::game::Rotation*>(p);
  }
  return _impl_.rotation_;
}
inline ::tower::game::Rotation* EntitySnapshot::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::tower::game::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:tower.game.EntitySnapshot.rotation)
  return _msg;
}
inline void EntitySnapshot::set_allocated_rotation(::tower::game::Rotation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.rotation_ = reinterpret_cast<::tower::game::Rotation*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.EntitySnapshot.rotation)
}

// optional float health = 6;
inline bool EntitySnapshot::has_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void EntitySnapshot::clear_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float EntitySnapshot::health() const {
  // @@protoc_insertion_point(field_get:tower.game.EntitySnapshot.health)
  return _internal_health();
}
inline void EntitySnapshot::set_health(float value) {
  _internal_set_health(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:tower.game.EntitySnapshot.health)
}
inline float EntitySnapshot::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_;
}
inline void EntitySnapshot::_internal_set_health(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = value;
}

// optional string state = 7;
inline bool EntitySnapshot::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EntitySnapshot::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EntitySnapshot::state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.EntitySnapshot.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntitySnapshot::set_state(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tower.game.EntitySnapshot.state)
}
inline std::string* EntitySnapshot::mutable_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:tower.game.EntitySnapshot.state)
  return _s;
}
inline const std::string& EntitySnapshot::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.state_.Get();
}
inline void EntitySnapshot::_internal_set_state(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.state_.Set(value, GetArena());
}
inline std::string* EntitySnapshot::_internal_mutable_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.state_.Mutable( GetArena());
}
inline std::string* EntitySnapshot::release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.EntitySnapshot.state)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.state_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void EntitySnapshot::set_allocated_state(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.state_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tower.game.EntitySnapshot.state)
}

// -------------------------------------------------------------------

// WorldSnapshot

// uint64 tick = 1;
inline void WorldSnapshot::clear_tick() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tick_ = ::uint64_t{0u};
}
inline ::uint64_t WorldSnapshot::tick() const {
  // @@protoc_insertion_point(field_get:tower.game.WorldSnapshot.tick)
  return _internal_tick();
}
inline void WorldSnapshot::set_tick(::uint64_t value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:tower.game.WorldSnapshot.tick)
}
inline ::uint64_t WorldSnapshot::_internal_tick() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tick_;
}
inline void WorldSnapshot::_internal_set_tick(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tick_ = value;
}

// uint64 timestamp = 2;
inline void WorldSnapshot::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t WorldSnapshot::timestamp() const {
  // @@protoc_insertion_point(field_get:tower.game.WorldSnapshot.timestamp)
  return _internal_timestamp();
}
inline void WorldSnapshot::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:tower.game.WorldSnapshot.timestamp)
}
inline ::uint64_t WorldSnapshot::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void WorldSnapshot::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// uint32 server_time_ms = 3;
inline void WorldSnapshot::clear_server_time_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_time_ms_ = 0u;
}
inline ::uint32_t WorldSnapshot::server_time_ms() const {
  // @@protoc_insertion_point(field_get:tower.game.WorldSnapshot.server_time_ms)
  return _internal_server_time_ms();
}
inline void WorldSnapshot::set_server_time_ms(::uint32_t value) {
  _internal_set_server_time_ms(value);
  // @@protoc_insertion_point(field_set:tower.game.WorldSnapshot.server_time_ms)
}
inline ::uint32_t WorldSnapshot::_internal_server_time_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_time_ms_;
}
inline void WorldSnapshot::_internal_set_server_time_ms(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_time_ms_ = value;
}

// repeated .tower.game.EntitySnapshot players = 4;
inline int WorldSnapshot::_internal_players_size() const {
  return _internal_players().size();
}
inline int WorldSnapshot::players_size() const {
  return _internal_players_size();
}
inline void WorldSnapshot::clear_players() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.players_.Clear();
}
inline ::tower::game::EntitySnapshot* WorldSnapshot::mutable_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tower.game.WorldSnapshot.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>* WorldSnapshot::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tower.game.WorldSnapshot.players)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_players();
}
inline const ::tower::game::EntitySnapshot& WorldSnapshot::players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.WorldSnapshot.players)
  return _internal_players().Get(index);
}
inline ::tower::game::EntitySnapshot* WorldSnapshot::add_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tower::game::EntitySnapshot* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:tower.game.WorldSnapshot.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>& WorldSnapshot::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tower.game.WorldSnapshot.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>&
WorldSnapshot::_internal_players() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>*
WorldSnapshot::_internal_mutable_players() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.players_;
}

// repeated .tower.game.EntitySnapshot monsters = 5;
inline int WorldSnapshot::_internal_monsters_size() const {
  return _internal_monsters().size();
}
inline int WorldSnapshot::monsters_size() const {
  return _internal_monsters_size();
}
inline void WorldSnapshot::clear_monsters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monsters_.Clear();
}
inline ::tower::game::EntitySnapshot* WorldSnapshot::mutable_monsters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tower.game.WorldSnapshot.monsters)
  return _internal_mutable_monsters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>* WorldSnapshot::mutable_monsters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tower.game.WorldSnapshot.monsters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_monsters();
}
inline const ::tower::game::EntitySnapshot& WorldSnapshot::monsters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.WorldSnapshot.monsters)
  return _internal_monsters().Get(index);
}
inline ::tower::game::EntitySnapshot* WorldSnapshot::add_monsters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tower::game::EntitySnapshot* _add = _internal_mutable_monsters()->Add();
  // @@protoc_insertion_point(field_add:tower.game.WorldSnapshot.monsters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>& WorldSnapshot::monsters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tower.game.WorldSnapshot.monsters)
  return _internal_monsters();
}
inline const ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>&
WorldSnapshot::_internal_monsters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monsters_;
}
inline ::google::protobuf::RepeatedPtrField<::tower::game::EntitySnapshot>*
WorldSnapshot::_internal_mutable_monsters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.monsters_;
}

// -------------------------------------------------------------------

// PlayerInput

// uint64 client_tick = 1;
inline void PlayerInput::clear_client_tick() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_tick_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerInput::client_tick() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerInput.client_tick)
  return _internal_client_tick();
}
inline void PlayerInput::set_client_tick(::uint64_t value) {
  _internal_set_client_tick(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerInput.client_tick)
}
inline ::uint64_t PlayerInput::_internal_client_tick() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_tick_;
}
inline void PlayerInput::_internal_set_client_tick(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_tick_ = value;
}

// uint64 player_id = 2;
inline void PlayerInput::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerInput::player_id() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerInput.player_id)
  return _internal_player_id();
}
inline void PlayerInput::set_player_id(::uint64_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerInput.player_id)
}
inline ::uint64_t PlayerInput::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_;
}
inline void PlayerInput::_internal_set_player_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_ = value;
}

// .tower.game.Vec3 movement_direction = 3;
inline bool PlayerInput::has_movement_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.movement_direction_ != nullptr);
  return value;
}
inline void PlayerInput::clear_movement_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.movement_direction_ != nullptr) _impl_.movement_direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tower::game::Vec3& PlayerInput::_internal_movement_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Vec3* p = _impl_.movement_direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Vec3&>(::tower::game::_Vec3_default_instance_);
}
inline const ::tower::game::Vec3& PlayerInput::movement_direction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.PlayerInput.movement_direction)
  return _internal_movement_direction();
}
inline void PlayerInput::unsafe_arena_set_allocated_movement_direction(::tower::game::Vec3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.movement_direction_);
  }
  _impl_.movement_direction_ = reinterpret_cast<::tower::game::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.PlayerInput.movement_direction)
}
inline ::tower::game::Vec3* PlayerInput::release_movement_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tower::game::Vec3* released = _impl_.movement_direction_;
  _impl_.movement_direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Vec3* PlayerInput::unsafe_arena_release_movement_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.PlayerInput.movement_direction)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tower::game::Vec3* temp = _impl_.movement_direction_;
  _impl_.movement_direction_ = nullptr;
  return temp;
}
inline ::tower::game::Vec3* PlayerInput::_internal_mutable_movement_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.movement_direction_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Vec3>(GetArena());
    _impl_.movement_direction_ = reinterpret_cast<::tower::game::Vec3*>(p);
  }
  return _impl_.movement_direction_;
}
inline ::tower::game::Vec3* PlayerInput::mutable_movement_direction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tower::game::Vec3* _msg = _internal_mutable_movement_direction();
  // @@protoc_insertion_point(field_mutable:tower.game.PlayerInput.movement_direction)
  return _msg;
}
inline void PlayerInput::set_allocated_movement_direction(::tower::game::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.movement_direction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.movement_direction_ = reinterpret_cast<::tower::game::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.PlayerInput.movement_direction)
}

// bool jump_pressed = 4;
inline void PlayerInput::clear_jump_pressed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jump_pressed_ = false;
}
inline bool PlayerInput::jump_pressed() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerInput.jump_pressed)
  return _internal_jump_pressed();
}
inline void PlayerInput::set_jump_pressed(bool value) {
  _internal_set_jump_pressed(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerInput.jump_pressed)
}
inline bool PlayerInput::_internal_jump_pressed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.jump_pressed_;
}
inline void PlayerInput::_internal_set_jump_pressed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jump_pressed_ = value;
}

// bool dash_pressed = 5;
inline void PlayerInput::clear_dash_pressed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dash_pressed_ = false;
}
inline bool PlayerInput::dash_pressed() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerInput.dash_pressed)
  return _internal_dash_pressed();
}
inline void PlayerInput::set_dash_pressed(bool value) {
  _internal_set_dash_pressed(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerInput.dash_pressed)
}
inline bool PlayerInput::_internal_dash_pressed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dash_pressed_;
}
inline void PlayerInput::_internal_set_dash_pressed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dash_pressed_ = value;
}

// .tower.game.Rotation camera_rotation = 6;
inline bool PlayerInput::has_camera_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_rotation_ != nullptr);
  return value;
}
inline void PlayerInput::clear_camera_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.camera_rotation_ != nullptr) _impl_.camera_rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tower::game::Rotation& PlayerInput::_internal_camera_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Rotation* p = _impl_.camera_rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Rotation&>(::tower::game::_Rotation_default_instance_);
}
inline const ::tower::game::Rotation& PlayerInput::camera_rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.PlayerInput.camera_rotation)
  return _internal_camera_rotation();
}
inline void PlayerInput::unsafe_arena_set_allocated_camera_rotation(::tower::game::Rotation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.camera_rotation_);
  }
  _impl_.camera_rotation_ = reinterpret_cast<::tower::game::Rotation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.PlayerInput.camera_rotation)
}
inline ::tower::game::Rotation* PlayerInput::release_camera_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tower::game::Rotation* released = _impl_.camera_rotation_;
  _impl_.camera_rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Rotation* PlayerInput::unsafe_arena_release_camera_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.PlayerInput.camera_rotation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tower::game::Rotation* temp = _impl_.camera_rotation_;
  _impl_.camera_rotation_ = nullptr;
  return temp;
}
inline ::tower::game::Rotation* PlayerInput::_internal_mutable_camera_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.camera_rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Rotation>(GetArena());
    _impl_.camera_rotation_ = reinterpret_cast<::tower::game::Rotation*>(p);
  }
  return _impl_.camera_rotation_;
}
inline ::tower::game::Rotation* PlayerInput::mutable_camera_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tower::game::Rotation* _msg = _internal_mutable_camera_rotation();
  // @@protoc_insertion_point(field_mutable:tower.game.PlayerInput.camera_rotation)
  return _msg;
}
inline void PlayerInput::set_allocated_camera_rotation(::tower::game::Rotation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.camera_rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.camera_rotation_ = reinterpret_cast<::tower::game::Rotation*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.PlayerInput.camera_rotation)
}

// .tower.game.Vec3 aim_direction = 7;
inline bool PlayerInput::has_aim_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.aim_direction_ != nullptr);
  return value;
}
inline void PlayerInput::clear_aim_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.aim_direction_ != nullptr) _impl_.aim_direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::tower::game::Vec3& PlayerInput::_internal_aim_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Vec3* p = _impl_.aim_direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Vec3&>(::tower::game::_Vec3_default_instance_);
}
inline const ::tower::game::Vec3& PlayerInput::aim_direction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.PlayerInput.aim_direction)
  return _internal_aim_direction();
}
inline void PlayerInput::unsafe_arena_set_allocated_aim_direction(::tower::game::Vec3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.aim_direction_);
  }
  _impl_.aim_direction_ = reinterpret_cast<::tower::game::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.PlayerInput.aim_direction)
}
inline ::tower::game::Vec3* PlayerInput::release_aim_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tower::game::Vec3* released = _impl_.aim_direction_;
  _impl_.aim_direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Vec3* PlayerInput::unsafe_arena_release_aim_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.PlayerInput.aim_direction)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::tower::game::Vec3* temp = _impl_.aim_direction_;
  _impl_.aim_direction_ = nullptr;
  return temp;
}
inline ::tower::game::Vec3* PlayerInput::_internal_mutable_aim_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.aim_direction_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Vec3>(GetArena());
    _impl_.aim_direction_ = reinterpret_cast<::tower::game::Vec3*>(p);
  }
  return _impl_.aim_direction_;
}
inline ::tower::game::Vec3* PlayerInput::mutable_aim_direction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::tower::game::Vec3* _msg = _internal_mutable_aim_direction();
  // @@protoc_insertion_point(field_mutable:tower.game.PlayerInput.aim_direction)
  return _msg;
}
inline void PlayerInput::set_allocated_aim_direction(::tower::game::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.aim_direction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.aim_direction_ = reinterpret_cast<::tower::game::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.PlayerInput.aim_direction)
}

// bool attack_pressed = 8;
inline void PlayerInput::clear_attack_pressed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_pressed_ = false;
}
inline bool PlayerInput::attack_pressed() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerInput.attack_pressed)
  return _internal_attack_pressed();
}
inline void PlayerInput::set_attack_pressed(bool value) {
  _internal_set_attack_pressed(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerInput.attack_pressed)
}
inline bool PlayerInput::_internal_attack_pressed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attack_pressed_;
}
inline void PlayerInput::_internal_set_attack_pressed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_pressed_ = value;
}

// uint64 target_entity = 9;
inline void PlayerInput::clear_target_entity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_entity_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerInput::target_entity() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerInput.target_entity)
  return _internal_target_entity();
}
inline void PlayerInput::set_target_entity(::uint64_t value) {
  _internal_set_target_entity(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerInput.target_entity)
}
inline ::uint64_t PlayerInput::_internal_target_entity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_entity_;
}
inline void PlayerInput::_internal_set_target_entity(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_entity_ = value;
}

// uint64 timestamp = 10;
inline void PlayerInput::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerInput::timestamp() const {
  // @@protoc_insertion_point(field_get:tower.game.PlayerInput.timestamp)
  return _internal_timestamp();
}
inline void PlayerInput::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:tower.game.PlayerInput.timestamp)
}
inline ::uint64_t PlayerInput::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void PlayerInput::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// ConnectionAccepted

// uint64 player_id = 1;
inline void ConnectionAccepted::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_ = ::uint64_t{0u};
}
inline ::uint64_t ConnectionAccepted::player_id() const {
  // @@protoc_insertion_point(field_get:tower.game.ConnectionAccepted.player_id)
  return _internal_player_id();
}
inline void ConnectionAccepted::set_player_id(::uint64_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:tower.game.ConnectionAccepted.player_id)
}
inline ::uint64_t ConnectionAccepted::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_;
}
inline void ConnectionAccepted::_internal_set_player_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_ = value;
}

// string session_token = 2;
inline void ConnectionAccepted::clear_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_token_.ClearToEmpty();
}
inline const std::string& ConnectionAccepted::session_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.ConnectionAccepted.session_token)
  return _internal_session_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectionAccepted::set_session_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tower.game.ConnectionAccepted.session_token)
}
inline std::string* ConnectionAccepted::mutable_session_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_token();
  // @@protoc_insertion_point(field_mutable:tower.game.ConnectionAccepted.session_token)
  return _s;
}
inline const std::string& ConnectionAccepted::_internal_session_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_token_.Get();
}
inline void ConnectionAccepted::_internal_set_session_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_token_.Set(value, GetArena());
}
inline std::string* ConnectionAccepted::_internal_mutable_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_token_.Mutable( GetArena());
}
inline std::string* ConnectionAccepted::release_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.ConnectionAccepted.session_token)
  return _impl_.session_token_.Release();
}
inline void ConnectionAccepted::set_allocated_session_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_token_.IsDefault()) {
          _impl_.session_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tower.game.ConnectionAccepted.session_token)
}

// uint64 server_tick = 3;
inline void ConnectionAccepted::clear_server_tick() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_tick_ = ::uint64_t{0u};
}
inline ::uint64_t ConnectionAccepted::server_tick() const {
  // @@protoc_insertion_point(field_get:tower.game.ConnectionAccepted.server_tick)
  return _internal_server_tick();
}
inline void ConnectionAccepted::set_server_tick(::uint64_t value) {
  _internal_set_server_tick(value);
  // @@protoc_insertion_point(field_set:tower.game.ConnectionAccepted.server_tick)
}
inline ::uint64_t ConnectionAccepted::_internal_server_tick() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_tick_;
}
inline void ConnectionAccepted::_internal_set_server_tick(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_tick_ = value;
}

// .tower.game.Vec3 spawn_position = 4;
inline bool ConnectionAccepted::has_spawn_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spawn_position_ != nullptr);
  return value;
}
inline void ConnectionAccepted::clear_spawn_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.spawn_position_ != nullptr) _impl_.spawn_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tower::game::Vec3& ConnectionAccepted::_internal_spawn_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tower::game::Vec3* p = _impl_.spawn_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::tower::game::Vec3&>(::tower::game::_Vec3_default_instance_);
}
inline const ::tower::game::Vec3& ConnectionAccepted::spawn_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.ConnectionAccepted.spawn_position)
  return _internal_spawn_position();
}
inline void ConnectionAccepted::unsafe_arena_set_allocated_spawn_position(::tower::game::Vec3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spawn_position_);
  }
  _impl_.spawn_position_ = reinterpret_cast<::tower::game::Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.ConnectionAccepted.spawn_position)
}
inline ::tower::game::Vec3* ConnectionAccepted::release_spawn_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tower::game::Vec3* released = _impl_.spawn_position_;
  _impl_.spawn_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::tower::game::Vec3* ConnectionAccepted::unsafe_arena_release_spawn_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.ConnectionAccepted.spawn_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tower::game::Vec3* temp = _impl_.spawn_position_;
  _impl_.spawn_position_ = nullptr;
  return temp;
}
inline ::tower::game::Vec3* ConnectionAccepted::_internal_mutable_spawn_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.spawn_position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tower::game::Vec3>(GetArena());
    _impl_.spawn_position_ = reinterpret_cast<::tower::game::Vec3*>(p);
  }
  return _impl_.spawn_position_;
}
inline ::tower::game::Vec3* ConnectionAccepted::mutable_spawn_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tower::game::Vec3* _msg = _internal_mutable_spawn_position();
  // @@protoc_insertion_point(field_mutable:tower.game.ConnectionAccepted.spawn_position)
  return _msg;
}
inline void ConnectionAccepted::set_allocated_spawn_position(::tower::game::Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.spawn_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.spawn_position_ = reinterpret_cast<::tower::game::Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:tower.game.ConnectionAccepted.spawn_position)
}

// uint32 spawn_floor = 5;
inline void ConnectionAccepted::clear_spawn_floor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spawn_floor_ = 0u;
}
inline ::uint32_t ConnectionAccepted::spawn_floor() const {
  // @@protoc_insertion_point(field_get:tower.game.ConnectionAccepted.spawn_floor)
  return _internal_spawn_floor();
}
inline void ConnectionAccepted::set_spawn_floor(::uint32_t value) {
  _internal_set_spawn_floor(value);
  // @@protoc_insertion_point(field_set:tower.game.ConnectionAccepted.spawn_floor)
}
inline ::uint32_t ConnectionAccepted::_internal_spawn_floor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spawn_floor_;
}
inline void ConnectionAccepted::_internal_set_spawn_floor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spawn_floor_ = value;
}

// -------------------------------------------------------------------

// ServerPacket

// .tower.game.WorldSnapshot snapshot = 1;
inline bool ServerPacket::has_snapshot() const {
  return payload_case() == kSnapshot;
}
inline bool ServerPacket::_internal_has_snapshot() const {
  return payload_case() == kSnapshot;
}
inline void ServerPacket::set_has_snapshot() {
  _impl_._oneof_case_[0] = kSnapshot;
}
inline void ServerPacket::clear_snapshot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kSnapshot) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.snapshot_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.snapshot_);
    }
    clear_has_payload();
  }
}
inline ::tower::game::WorldSnapshot* ServerPacket::release_snapshot() {
  // @@protoc_insertion_point(field_release:tower.game.ServerPacket.snapshot)
  if (payload_case() == kSnapshot) {
    clear_has_payload();
    auto* temp = _impl_.payload_.snapshot_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tower::game::WorldSnapshot& ServerPacket::_internal_snapshot() const {
  return payload_case() == kSnapshot ? *_impl_.payload_.snapshot_ : reinterpret_cast<::tower::game::WorldSnapshot&>(::tower::game::_WorldSnapshot_default_instance_);
}
inline const ::tower::game::WorldSnapshot& ServerPacket::snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.ServerPacket.snapshot)
  return _internal_snapshot();
}
inline ::tower::game::WorldSnapshot* ServerPacket::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tower.game.ServerPacket.snapshot)
  if (payload_case() == kSnapshot) {
    clear_has_payload();
    auto* temp = _impl_.payload_.snapshot_;
    _impl_.payload_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerPacket::unsafe_arena_set_allocated_snapshot(::tower::game::WorldSnapshot* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_snapshot();
    _impl_.payload_.snapshot_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.ServerPacket.snapshot)
}
inline ::tower::game::WorldSnapshot* ServerPacket::_internal_mutable_snapshot() {
  if (payload_case() != kSnapshot) {
    clear_payload();
    set_has_snapshot();
    _impl_.payload_.snapshot_ =
        ::google::protobuf::Message::DefaultConstruct<::tower::game::WorldSnapshot>(GetArena());
  }
  return _impl_.payload_.snapshot_;
}
inline ::tower::game::WorldSnapshot* ServerPacket::mutable_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tower::game::WorldSnapshot* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:tower.game.ServerPacket.snapshot)
  return _msg;
}

// .tower.game.ChunkData chunk_data = 2;
inline bool ServerPacket::has_chunk_data() const {
  return payload_case() == kChunkData;
}
inline bool ServerPacket::_internal_has_chunk_data() const {
  return payload_case() == kChunkData;
}
inline void ServerPacket::set_has_chunk_data() {
  _impl_._oneof_case_[0] = kChunkData;
}
inline void ServerPacket::clear_chunk_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kChunkData) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.chunk_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.chunk_data_);
    }
    clear_has_payload();
  }
}
inline ::tower::game::ChunkData* ServerPacket::release_chunk_data() {
  // @@protoc_insertion_point(field_release:tower.game.ServerPacket.chunk_data)
  if (payload_case() == kChunkData) {
    clear_has_payload();
    auto* temp = _impl_.payload_.chunk_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.chunk_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tower::game::ChunkData& ServerPacket::_internal_chunk_data() const {
  return payload_case() == kChunkData ? *_impl_.payload_.chunk_data_ : reinterpret_cast<::tower::game::ChunkData&>(::tower::game::_ChunkData_default_instance_);
}
inline const ::tower::game::ChunkData& ServerPacket::chunk_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.ServerPacket.chunk_data)
  return _internal_chunk_data();
}
inline ::tower::game::ChunkData* ServerPacket::unsafe_arena_release_chunk_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tower.game.ServerPacket.chunk_data)
  if (payload_case() == kChunkData) {
    clear_has_payload();
    auto* temp = _impl_.payload_.chunk_data_;
    _impl_.payload_.chunk_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerPacket::unsafe_arena_set_allocated_chunk_data(::tower::game::ChunkData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_chunk_data();
    _impl_.payload_.chunk_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.ServerPacket.chunk_data)
}
inline ::tower::game::ChunkData* ServerPacket::_internal_mutable_chunk_data() {
  if (payload_case() != kChunkData) {
    clear_payload();
    set_has_chunk_data();
    _impl_.payload_.chunk_data_ =
        ::google::protobuf::Message::DefaultConstruct<::tower::game::ChunkData>(GetArena());
  }
  return _impl_.payload_.chunk_data_;
}
inline ::tower::game::ChunkData* ServerPacket::mutable_chunk_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tower::game::ChunkData* _msg = _internal_mutable_chunk_data();
  // @@protoc_insertion_point(field_mutable:tower.game.ServerPacket.chunk_data)
  return _msg;
}

// .tower.game.ConnectionAccepted connection_accepted = 3;
inline bool ServerPacket::has_connection_accepted() const {
  return payload_case() == kConnectionAccepted;
}
inline bool ServerPacket::_internal_has_connection_accepted() const {
  return payload_case() == kConnectionAccepted;
}
inline void ServerPacket::set_has_connection_accepted() {
  _impl_._oneof_case_[0] = kConnectionAccepted;
}
inline void ServerPacket::clear_connection_accepted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kConnectionAccepted) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.connection_accepted_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.connection_accepted_);
    }
    clear_has_payload();
  }
}
inline ::tower::game::ConnectionAccepted* ServerPacket::release_connection_accepted() {
  // @@protoc_insertion_point(field_release:tower.game.ServerPacket.connection_accepted)
  if (payload_case() == kConnectionAccepted) {
    clear_has_payload();
    auto* temp = _impl_.payload_.connection_accepted_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.connection_accepted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tower::game::ConnectionAccepted& ServerPacket::_internal_connection_accepted() const {
  return payload_case() == kConnectionAccepted ? *_impl_.payload_.connection_accepted_ : reinterpret_cast<::tower::game::ConnectionAccepted&>(::tower::game::_ConnectionAccepted_default_instance_);
}
inline const ::tower::game::ConnectionAccepted& ServerPacket::connection_accepted() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.ServerPacket.connection_accepted)
  return _internal_connection_accepted();
}
inline ::tower::game::ConnectionAccepted* ServerPacket::unsafe_arena_release_connection_accepted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tower.game.ServerPacket.connection_accepted)
  if (payload_case() == kConnectionAccepted) {
    clear_has_payload();
    auto* temp = _impl_.payload_.connection_accepted_;
    _impl_.payload_.connection_accepted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerPacket::unsafe_arena_set_allocated_connection_accepted(::tower::game::ConnectionAccepted* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_connection_accepted();
    _impl_.payload_.connection_accepted_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.ServerPacket.connection_accepted)
}
inline ::tower::game::ConnectionAccepted* ServerPacket::_internal_mutable_connection_accepted() {
  if (payload_case() != kConnectionAccepted) {
    clear_payload();
    set_has_connection_accepted();
    _impl_.payload_.connection_accepted_ =
        ::google::protobuf::Message::DefaultConstruct<::tower::game::ConnectionAccepted>(GetArena());
  }
  return _impl_.payload_.connection_accepted_;
}
inline ::tower::game::ConnectionAccepted* ServerPacket::mutable_connection_accepted() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tower::game::ConnectionAccepted* _msg = _internal_mutable_connection_accepted();
  // @@protoc_insertion_point(field_mutable:tower.game.ServerPacket.connection_accepted)
  return _msg;
}

// bytes pong = 4;
inline bool ServerPacket::has_pong() const {
  return payload_case() == kPong;
}
inline void ServerPacket::set_has_pong() {
  _impl_._oneof_case_[0] = kPong;
}
inline void ServerPacket::clear_pong() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPong) {
    _impl_.payload_.pong_.Destroy();
    clear_has_payload();
  }
}
inline const std::string& ServerPacket::pong() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.ServerPacket.pong)
  return _internal_pong();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerPacket::set_pong(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() != kPong) {
    clear_payload();

    set_has_pong();
    _impl_.payload_.pong_.InitDefault();
  }
  _impl_.payload_.pong_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tower.game.ServerPacket.pong)
}
inline std::string* ServerPacket::mutable_pong() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:tower.game.ServerPacket.pong)
  return _s;
}
inline const std::string& ServerPacket::_internal_pong() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (payload_case() != kPong) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.payload_.pong_.Get();
}
inline void ServerPacket::_internal_set_pong(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() != kPong) {
    clear_payload();

    set_has_pong();
    _impl_.payload_.pong_.InitDefault();
  }
  _impl_.payload_.pong_.Set(value, GetArena());
}
inline std::string* ServerPacket::_internal_mutable_pong() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() != kPong) {
    clear_payload();

    set_has_pong();
    _impl_.payload_.pong_.InitDefault();
  }
  return _impl_.payload_.pong_.Mutable( GetArena());
}
inline std::string* ServerPacket::release_pong() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.ServerPacket.pong)
  if (payload_case() != kPong) {
    return nullptr;
  }
  clear_has_payload();
  return _impl_.payload_.pong_.Release();
}
inline void ServerPacket::set_allocated_pong(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_payload()) {
    clear_payload();
  }
  if (value != nullptr) {
    set_has_pong();
    _impl_.payload_.pong_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tower.game.ServerPacket.pong)
}

inline bool ServerPacket::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ServerPacket::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ServerPacket::PayloadCase ServerPacket::payload_case() const {
  return ServerPacket::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientPacket

// .tower.game.PlayerInput input = 1;
inline bool ClientPacket::has_input() const {
  return payload_case() == kInput;
}
inline bool ClientPacket::_internal_has_input() const {
  return payload_case() == kInput;
}
inline void ClientPacket::set_has_input() {
  _impl_._oneof_case_[0] = kInput;
}
inline void ClientPacket::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kInput) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.input_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.input_);
    }
    clear_has_payload();
  }
}
inline ::tower::game::PlayerInput* ClientPacket::release_input() {
  // @@protoc_insertion_point(field_release:tower.game.ClientPacket.input)
  if (payload_case() == kInput) {
    clear_has_payload();
    auto* temp = _impl_.payload_.input_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.input_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tower::game::PlayerInput& ClientPacket::_internal_input() const {
  return payload_case() == kInput ? *_impl_.payload_.input_ : reinterpret_cast<::tower::game::PlayerInput&>(::tower::game::_PlayerInput_default_instance_);
}
inline const ::tower::game::PlayerInput& ClientPacket::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.ClientPacket.input)
  return _internal_input();
}
inline ::tower::game::PlayerInput* ClientPacket::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tower.game.ClientPacket.input)
  if (payload_case() == kInput) {
    clear_has_payload();
    auto* temp = _impl_.payload_.input_;
    _impl_.payload_.input_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientPacket::unsafe_arena_set_allocated_input(::tower::game::PlayerInput* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_input();
    _impl_.payload_.input_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tower.game.ClientPacket.input)
}
inline ::tower::game::PlayerInput* ClientPacket::_internal_mutable_input() {
  if (payload_case() != kInput) {
    clear_payload();
    set_has_input();
    _impl_.payload_.input_ =
        ::google::protobuf::Message::DefaultConstruct<::tower::game::PlayerInput>(GetArena());
  }
  return _impl_.payload_.input_;
}
inline ::tower::game::PlayerInput* ClientPacket::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tower::game::PlayerInput* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:tower.game.ClientPacket.input)
  return _msg;
}

// bytes ping = 2;
inline bool ClientPacket::has_ping() const {
  return payload_case() == kPing;
}
inline void ClientPacket::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void ClientPacket::clear_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPing) {
    _impl_.payload_.ping_.Destroy();
    clear_has_payload();
  }
}
inline const std::string& ClientPacket::ping() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tower.game.ClientPacket.ping)
  return _internal_ping();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientPacket::set_ping(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() != kPing) {
    clear_payload();

    set_has_ping();
    _impl_.payload_.ping_.InitDefault();
  }
  _impl_.payload_.ping_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tower.game.ClientPacket.ping)
}
inline std::string* ClientPacket::mutable_ping() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:tower.game.ClientPacket.ping)
  return _s;
}
inline const std::string& ClientPacket::_internal_ping() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (payload_case() != kPing) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.payload_.ping_.Get();
}
inline void ClientPacket::_internal_set_ping(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() != kPing) {
    clear_payload();

    set_has_ping();
    _impl_.payload_.ping_.InitDefault();
  }
  _impl_.payload_.ping_.Set(value, GetArena());
}
inline std::string* ClientPacket::_internal_mutable_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() != kPing) {
    clear_payload();

    set_has_ping();
    _impl_.payload_.ping_.InitDefault();
  }
  return _impl_.payload_.ping_.Mutable( GetArena());
}
inline std::string* ClientPacket::release_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tower.game.ClientPacket.ping)
  if (payload_case() != kPing) {
    return nullptr;
  }
  clear_has_payload();
  return _impl_.payload_.ping_.Release();
}
inline void ClientPacket::set_allocated_ping(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_payload()) {
    clear_payload();
  }
  if (value != nullptr) {
    set_has_ping();
    _impl_.payload_.ping_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tower.game.ClientPacket.ping)
}

inline bool ClientPacket::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ClientPacket::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ClientPacket::PayloadCase ClientPacket::payload_case() const {
  return ClientPacket::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace game
}  // namespace tower


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_game_5fstate_2eproto_2epb_2eh
